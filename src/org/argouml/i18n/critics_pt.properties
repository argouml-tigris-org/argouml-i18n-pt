# $Id$
# Based on critics.properties,v 1.14.
# Copyright (c) 2005, 2006 The Regents of the University of California. All
# Rights Reserved. Permission to use, copy, modify, and distribute this
# software and its documentation without fee, and without a written
# agreement is hereby granted, provided that the above copyright notice
# and this paragraph appear in all copies.  This software program and
# documentation are copyrighted by The Regents of the University of
# California. The software program and documentation are supplied "AS
# IS", without any accompanying services from The Regents. The Regents
# does not warrant that the operation of the program will be
# uninterrupted or error-free. The end-user understands that the program
# was developed for research purposes and is advised not to rely
# exclusively on the program for any reason.  IN NO EVENT SHALL THE
# UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
# SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
# UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
#
# Created from UMLCognitiveResourceBundle.java
#
# The keys are generated from the class names of the classes that use them.
#
critics.CrAlreadyRealizes-desc = A classe seleccionada já concretiza \
        indirectamente a Interface {item.extra}.  Não há necessidade de \
        realizar directamente outra vez.\n\nSimplificar o Desenho é sempre boa \
        ideia. Pode ignorar este item \"por fazer\" se quiser tornar explicito \
        de que a Classe selecionada realiza esta Interface.\n\nPara resolver \
        isto , selecione a Realização (linha tracejada com seta triangular \
        branca) e pressione a combinação de teclas \"Ctrl-Delete\".
critics.CrAlreadyRealizes-head = Remova Realizações desnecessárias de \
        <ocl>self</ocl>
critics.CrAssocNameConflict-desc = Cada elemento de um espaço de nomes tem de \
        um nome único. \n\nNomemclatura clara e não ambígua é o elemento chave \
        da geração de código e torna o desenho muito mais compreensível e \
        fácil de manter. \n\nPara resolver isto, use o botão \"Próximo>\", ou \
        seleccione manualmente os elementos e use o separador das Propriedades \
        para mudar os seus nomes.
critics.CrAssocNameConflict-head = Resolva Conflito de Nome de Associação
critics.CrAttrNameConflict-desc = Os atributos têm de ter nomes distintos. \
        Esta crítica pode ter sido dispoletada como resultado de um nome de \
        atributo herdado. \n\nNomemclatura clara e não ambígua é o elemento \
        chave da geração de código e torna o desenho muito mais compreensível \
        e fácil de manter. \n\nPara resolver isto, use o botão \"Próximo>\", \
        ou seleccione manualmente um dos atributos em conflito desta classe e \
        mude o seu nome.
critics.CrAttrNameConflict-head = Reveja os Nomes de Atributos para Evitar \
        Conflito
critics.CrCallWithoutReturn-desc = Cada chamada ou acção de envio requere uma \
        acção de retorno,\n mas esta Ligação não tem nenhuma acção de retorno.
critics.CrCallWithoutReturn-head = Acções de Retorno em Falta
critics.CrCircularAssocClass-desc = Classes Associativas não podem incluír \
        papeis que referem directamente de volta à Classe Associativa.
critics.CrCircularAssocClass-head = Associação Circular
critics.CrCircularComposition-desc = Relações de Composição (losangulos \
        pretos) não podem ter ciclos. \n\nUma hierarquia de agregação legal \
        é necessária para a geração de código e correcção do desenho. \n\nPara \
        resolver isto, use o botão \"Próximo>\", ou seleccione manualmente uma \
        das associações no ciclo e remova-a ou mude a sua agregação para algo \
        que não seja composto.
critics.CrCircularComposition-head = Remova Composição Circular
critics.CrCircularInheritance-desc = Relações de Herança não podem ter ciclos \
        \n\nUma hierarquia de heranças legal é necessária para a geração de \
        código e correcção do desenho.
critics.CrCircularInheritance-head = Remova a Herança Circular de \
        <ocl>self</ocl>
critics.CrClassMustBeAbstract-desc = Classes que incluam ou herdem métodos \
        abstractos de classes base ou interfaces têm de estar marcadas como \
        abstractas. \n\nDecidir que classes são abstractas ou concretas é uma \
        parte chave do desenho de hierarquias de classes.\n\nPara corrigir \
        isto, use o botão \"Próximo>\" , ou seleccione manualmente a classe e \
        use o separador de propriedades para adicionar palavra-chave \
        Abstracta, ou implemente manualmente cada operação abstracta que é \
        herdada da classe base ou interface.
critics.CrClassMustBeAbstract-head = A Classe <ocl>self</ocl> Tem De Ser \
        Abstracta
critics.CrClassWithoutComponent-desc = Em Diagramas de Instalação as classes \
        estão normalmente dentro de componentes.
critics.CrClassWithoutComponent-head = As Classes Normalmente Estão Dentro de \
        Componentes
critics.CrCompInstanceWithoutNode-desc = Existem instancias de nós no \
        Diagrama. Assim, tem um Diagrama de Instaçação real, e nestes as \
        instâncias de componentes geralmente residem em instâncias de nós.
critics.CrCompInstanceWithoutNode-head = Instâncias de Componentes \
        Encontram-se Normalmente Dentro De Nós
critics.CrComponentWithoutNode-desc = Existem nós no diagrama. Portanto, \
        tem um Diagrama de Instalação real, e nestes os componentes \
        os componentes normalmente residem nos nós.
critics.CrComponentWithoutNode-head = Os Componentes Normalmente Estão Dentro \
        Dos Nós
critics.CrConflictingComposites-desc = Um papel composto (losangulo preto) \
        de uma associação indica que as instâncias daquela classe contêm \
        instâncias das classes associadas. Uma vez que cada instância só pode \
        estar contida num único objecto, cada objecto pode ser 'parte' de no \
        máximo uma relação é-parte-de.\n\nUm bom desenho OO depende da \
        construção de boas relações é-parte-de.\n\nPara resolver isto, use o \
        botão \"Próximo>\", ou mude manualmente uma associação de modo a ter \
        multiplicidade 0..1 ou 1..1, ou outro tipo de agregação (por exemplo, \
        um losangulo branco é menos restrito), ou remova uma das associações.
critics.CrConflictingComposites-head = Remova Associaçõe Compostas em Conflito
critics.CrConsiderSingleton-desc = <ocl>self</ocl> não tem nenhum atributo \
        não estático nem nenhuma associação que seja navegável a partir das \
        instâncias desta classe. Isto significa que cada instância desta \
        classe será idêntica a todas as outras instâncias, uma vez que não \
        existirá nada nas instâncias que as diferencie.\n\nNestas \
        circunstâncias deve considerar tornar explicito de que tem exactamente \
        uma única instância desta classe, através do Padrão Singleton. \
        Utilizando o Padrão Singleton pode salvar tempo e espaço de \
        memória. Dentro do ArgoUML pode ser feito através do estereótipo \
        <<singleton>> nesta classe.\n\nSe não é a sua intenção ter uma única \
        instância, deve definir variáveis de instância (isto é, atributos não \
        estáticos) e/ou associação de saída que irão representar diferenças \
        entre as instâncias. \n\nTendo especificado <ocl>self</ocl> como \
        Singleton, precisa de definir a classe de modo a que só exista uma \
        única instância. Isto irá completar a parte de representação de \
        informação do seu desenho. Para obter isto deverá fazer o seguinte.\n\n\
        1. Defina um atributo estático (uma variável de classe) que contenha a \
        instância. Isto terá portanto <ocl>self</ocl> como tipo.\n\n2. \
        Providencie só constructores privados para <ocl>self</ocl> de modo a \
        que novas instâncias não possam ser feitas por outro código. A criação \
        de uma única instância podia ser obtida através de uma operação \
        ajudante apropriada, que invoca este constructor privado só uma vez. \n\
        \n3. Providencie pelo menos um constructor para sobrepôr o constructor \
        por omissão, de modo a que o constructor por omissão não seja usado \
        para criar multiplas instancias.\n\nNo padrão UML 1.4, um constructor \
        é uma operação com o estereótipo <<create>>.\n\nPor convenção em Java \
        e C++ um constructor tem o mesmo nome que a classe, não é estático, \
        e não retorna nenhum valor. Note que no ArgoUML isto significa que \
        terá de remover o valor de retorno criado por omissão para a operação \
        de constructor.
critics.CrConsiderSingleton-head = Considere Utilizar o Padrão Singleton para \
        <ocl>self</ocl>
critics.CrConstructorNeeded-desc = Ainda não definiu um constructor para a \
        classe <ocl>self</ocl>. Os constructores inicializam novas instâncias \
        de modo a que os seus atributos tenham valores válidos. Provavelmente \
        esta classe precisa de um constructor porque nem todos os seus \
        atributos têm valores iniciais.\n\nDefinir bons constructores é a \
        chave para estabelecer invariantes de classe , e estas são uma ajuda \
        poderosa para escrever código sólido .\n\nPara resolver isto, adicione \
        um constructor manualmente clicando em <ocl>self</ocl> na zona do \
        navegador e adicionando uma operação através do menu pop-up sensível a \
        contexto no separador das propriedades, ou seleccionando \
        <ocl>self</ocl> onde apareça num diagrama de classes e usando a \
        ferramenta \"Adicionar Operação\". Depois use o separador Propriedades \
        na zona Detalhes para seleccionar o estereótipo <<create>> na \
        operação.\n\nUm constructor é uma operação com o estereótipo <<create>>.
critics.CrConstructorNeeded-head = Adicione Constructor a <ocl>self</ocl>
critics.CrCrossNamespaceAssoc-desc = Cada classe, interface ou outro \
        classificador (<ocl>self</ocl>) involvido numa associação deve estar \
        no nome de espaços da associação.\n\nSe não for este o caso, então não \
        haverá maneira das classes, interfaces ou outros classificadores \
        nomearem a referência uns dos outros usando a associação.\n\nNote que \
        esta crítica presentemente não interpreta nomes de espaços \
        hierárquicos. Assim, irá disparar se os componentes finais dos nomes \
        de espaços são diferentes, mesmo que partilhem uma raíz comum, e esta \
        crítica dessa ser interpretada tendo isso em conta.\n\nPara resolver \
        isto, apague a associação e volte a criá-la num diagrama cujo nome de \
        espaços inclua as classes, interfaces e classificadores involvidos.
critics.CrCrossNamespaceAssoc-head = O Classificador <ocl>self</ocl> não está \
        no Nome de Espaços da sua Associação
critics.CrDisambigClassName-desc = Cada classe e interface dentro de um pacote \
        têm de ter um nome único. Existem pelo menos dois elementos neste \
        pacote chamados \"<ocl>self</ocl>\".\n\nNomemclatura clara e não \
        ambígua é um elemento chave na geração de código e torna o desenho \
        mais compreensível e fácil de manter. \n\nPara resolver isto, use o \
        botão \"Próximo>\", ou seleccione manualmente uma das classes em \
        conflito e use o separador Propriedades para mudar os seus nomes.
critics.CrDisambigClassName-head = Escolha um Nome Único para <ocl>self</ocl>
critics.CrDisambigStateName-desc = Cada estado dentro de uma máquina de \
        estados tem de ter um nome único. Existem pelo menos dois estados \
        nesta máquina com o nome \"<ocl>self</ocl>\".\n\nNomemclatura clara e \
        não ambígua é um elemento chave na geração de código e torna o desenho \
        mais compreensível e fácil de manter. \n\nPara resolver isto, use o \
        botão \"Próximo>\", ou seleccione manualmente um dos estados em \
        conflito e use o separador \"Propriedades\" para mudar os seus nomes.
critics.CrDisambigStateName-head = Escolha um Nome Único para <ocl>self</ocl>
critics.CrDupParamName-desc = Cada parâmetro numa operação tem de ter um nome \
        único. \n\nNomemclatura limpa e não ambígua é necessária para a \
        geração de código e para obter desenhos claros e fáceis de manter.\n\n\
        Para resolver isto, use o botão \"Próximo>\", ou mude manualmente o \
        nome de um dos parâmetros desta operação.
critics.CrDupParamName-head = Nome de Parâmetro duplicado
critics.CrDupRoleNames-desc = A Associação <ocl>self</ocl> tem dois (ou mais) \
        papeis com o mesmo nome.\n\nNomemclatura clara e não ambígua é um \
        elemento chave na geração de código e torna o desenho mais \
        compreensível e fácil de manter.\n\nPara resolver isto seleccione \
        <ocl>self</ocl> manualmente e use o separador das Propriedades para \
        mudar um ou mais dos nomes de papeis em conflito.
critics.CrDupRoleNames-head = Nomes de Papeis de Fim duplicados para \
        <ocl>self</ocl>
critics.CrEmptyPackage-desc = Ainda não colocou nada no pacote <ocl>self</ocl>.\
         Normalmente os pacotes contêm grupos de classes relacionadas.\n\n\
        Definir e usar pacote é um elemento chave do desenho viável de manter.\
        \n\nPara resolver isto, seleccione o pacote <ocl>self</ocl> no painel\
        navegador e adicione diagramas ou elementos de modelo tais como \
        classes ou casos de utilização.
critics.CrEmptyPackage-head = Adicione Elementos ao Pacote <ocl>self</ocl>
critics.CrFinalSubclassed-desc = A palavra chave 'leaf' indica que a classe \
        não é suposto ter sub-classes. Esta classe ou interface está marcada \
        como 'leaf' e tem sub-classes.\n\nUma hierarquia de classes bem \
        estruturada que contempla e suporta extensão intencionais é uma parte \
        importante para obter um desenho compreensivel e fácil de manter.\n\n\
        Para resolver isto, use o botão \"Próximo>\", ou seleccione \
        manualmente a classe e mude a sua classe base, ou seleccione a classe \
        basee use o separador das propriedades para remover a palavra-chave \
        'leaf'.
critics.CrFinalSubclassed-head = Remova a Palavra-chave 'Leaf' ou Remova \
        Sub-classes de <ocl>self</ocl>
critics.CrForkOutgoingTransition-desc = A fonte de <ocl>self</ocl> é um \
        Pseudo-estado de Difusão, mas o seu alvo não é um Estado. Um segmento \
        de difusão deve sempre ter como alvo um estado.\n\nÉ necessário \
        definir transições válidas para completar a especificação \
        comportamental do seu desenho.\n\nPara corrigir isto, carregue em \
        remover esta transição clicando na transição do diagrama e carregando \
        em \"Ctrl-Delete\". Também pode mudar a fonte dos estados de transição \
        ou destino.
critics.CrForkOutgoingTransition-head = Alvo inválido para transição
critics.CrIllegalGeneralization-desc = Elementos de modelo só podem ser \
        herdados por outros do mesmo tipo. \n\nUm hierarquia de herança válida \
        é necessária para geração de código e correcção do desenho. \n\nPara \
        resolver isto, use o botão \"Próximo>\", ou seleccione manualmente a \
        seta de generalização e remova-a.
critics.CrIllegalGeneralization-head = Generalização Inválida
critics.CrIllegalName-desc = Os nomes de elementos do modelo têm de ser \
        sequências de letras, números, e sublinhas. Não podem conter \
        pontuação. \n\nA geração de código requere nomes válidos para que o \
        código resultante compile correctamente. \n\nPara resolver isto, \
        seleccione manualmente o elemento em foco e o use o separador \
        Propriedades para lhe dar um nome diferente.
critics.CrIllegalName-head = Escolha um Nome Válido para <ocl>self</ocl>
critics.CrInstanceWithoutClassifier-desc = Instâncias têm um classificador.
critics.CrInstanceWithoutClassifier-head = Defina o Classificador
critics.CrInterfaceAllPublic-desc = As interfaces têm como objectivo \
        especificar o conjunto de operações que as outras classes devem \
        implementar. Têm de ser públicas. \n\nUm conjunto bem desenhado de \
        interfaces é uma boa maneira para definir possíveis extensões a uma \
        infraestrutura de classes. \n\nPara resolver isto, use o botão \
        \"Próximo>\", ou seleccione manualmente as operações da interface e \
        use o separador Propriedades para torná-las públicas.
critics.CrInterfaceAllPublic-head = Operações em Interfaces têm de ser Públicas
critics.CrInterfaceOperOnly-desc = As interfaces têm como objectivo \
        especificar o conjunto de operações que as outras classes devem \
        implementar. Não implementam essas operações propriamente ditas, e não \
        ter atributos. \n\nUm conjunto bem desenhado de interfaces é uma boa \
        maneira para definir possíveis extensões a uma infraestrutura de \
        classes. \n\nPara resolver isto, use o botão \"Próximo>\", ou \
        seleccione manualmente a interface e use o separador Propriedades para \
        remover todos os atributos.
critics.CrInterfaceOperOnly-head = Interfaces só podem ter Operações
critics.CrInterfaceWithoutComponent-desc = Em diagramas de instalação, as \
        interfaces encontram-se normalmente dentro dos componentes.
critics.CrInterfaceWithoutComponent-head = Interfaces estão normalmente dentro \
        de Componentes
critics.CrInvalidBranch-desc = Este estado branch (escolha or junção) tem um \
        número inválido de transições. Normalmente estados branch têm pelo \
        menos uma transição de entrada e pelo menos uma transição de saída. \n\
        \nÉ necessário definir transições de estado correctas de modo a \
        completar a especificação comportamentas do seu desenho. \n\nPara \
        resolver isto, adicione transições através da ferramenta de transições.
critics.CrInvalidBranch-head = Adicione Transições de Escolha/Junção
critics.CrInvalidFork-desc = Este estado de difusão tem um número inválido de \
        transições. Normalmente estados de difusão têm uma transição de \
        entrada e duas ou mais de saída . \n\nÉ necessário definir transições \
        de estado correctas de modo a completar a especificação comportamental \
        do seu desenho. \n\nPara resolver isto, adicione ou remova transições \
        manualmente.
critics.CrInvalidFork-head = Mude as Transições de Difusão
critics.CrInvalidForkTriggerOrGuard-desc = A Transição em foco não deve ter um \
        disparador ou condição de guarda porque é uma transição de saída de um \
        Pseudo-estado de Difusão. As transições que saem de um vértice de \
        difusão não podem ter disparadores ou condições de guarda.\n\nÉ \
        necessário definir transições válidas de modo a completar a \
        corrigir isto, remova o disparador selecionado-o na zona Explorador e \
        especificação comportamental do seu desenho.\n\nPara removendo-o do \
        modelo através do menu obtido com um clique direito no rato. Ou, no \
        caso de uma condição de guarda, remova-a com um duplo clique no campo \
        de condição de guarda da transição e carregando em \"Ctrl-Delete\".
critics.CrInvalidForkTriggerOrGuard-head = Remova Disparador ou Condição de \
        Guarda da Transição de Saída Difusa
critics.CrInvalidHistory-desc = Este estado História tem um número inválido \
        de transições. Normalmente os estados de História Superficial e \
        História Profunda têm no máximo um transição de saída. \n\nÉ \
        necessário definir transições de estado correctas de modo a completar \
        a especificação comportamental do seu desenho. \n\nPara corrigir isto, \
        remova transições clicando na transição no diagrama e carregando em \
        \"Ctrl-Delete\".
critics.CrInvalidHistory-head = Remova Transições de Saída a mais
critics.CrInvalidInitial-desc = Este estado inicial tem um número inválido de \
        transições. Normalmente estados iniciais têm no máximo uma transição \
        de saída.\n\nÉ necessário definir transições válidas de modo a \
        completar a especificação comportamental do seu desenho. \n\nPara \
        corrigir isto, remova transições clicando na transição no diagrama e \
        carregando em \"Ctrl-Delete\".
critics.CrInvalidInitial-head = Remova Transições de Saída a mais
critics.CrInvalidJoin-desc = Este estado de junta tem um número inválido de \
        transições. Normalmente estados de junta têm duas ou mais transições \
        de entrada e uma transição de saída. \n\nÉ necessário definir \
        transições de estado correctas de modo a completar a especificação \
        comportamental do seu desenho. \n\nPara  resolver isto, adicione ou \
        remova transições manualmente.
critics.CrInvalidJoin-head = Mude Transições de Junta
critics.CrInvalidJoinTriggerOrGuard-desc = A transição em foco não deve ter um \
        disparador ou condição de guarda porque é uma transição de entrada de \
        um Pseudo-estado de Junta. As transições que entram num vértice de \
        junta não devem ter disparadores ou condições de guarda.\n\nÉ \
        necessário definir transições de estado correctas de modo a completar \
        a especificação comportamental do seu desenho.\n\nPara corrigir isto, \
        remova o disparador selecionando-o na zona Explorador e removendo-o do \
        modelo com o menu de clique direito no rato. Ou, no caso de uma \
        condição de guarda, remova-a com um duplo clique no campo de condição \
        de guarda da transição e carregando em \"Ctrl-Delete\".
critics.CrInvalidJoinTriggerOrGuard-desc = A Transição em foco não deve ter um \
        disparador ou condição de guarda porque é um Pseudo-Estado de Junta de \
        uma transição de entrada. As transições que entram num vértice não \
        podem ter disparadores ou condições de guarda.\n\nÉ necessário definir \
        transições válidas para completar a especificação comportamental do \
        seu desenho.\n\nPara corrigir isto, remova o disparador selecionando-o \
        na zona Explorador e escolhendo a opção \"Remover do Modelo\" no menu que \
        aparece com um clique direito no rato. Ou, no caso de uma condição de \
        guarda, remova-a com um duplo clique no campo de guarda da transição e \
        carregando em \"Ctrl-Delete\".
critics.CrInvalidJoinTriggerOrGuard-head = Remova Disparador ou Condição de \
        Guarda da Transição de Junta de entrada
critics.CrInvalidPseudoStateTrigger-desc = A Transição em foco não deve ter um \
        disparador porque é um Pseudo-Estado de Junta de uma transição de \
        saída. As transições que saem de um pseudo-estado não podem ter \
        disparadores.\n\nÉ necessário definir transições válidas para \
        completar a especificação comportamental do seu desenho.\n\nPara \
        corrigir isto, remova o disparador seleccionando-o na zona Explorador \
        ou na zona Propriedades e escolhendo a opção \"Remover do Modelo\" no \
        menu que aparece com um clique direito no rato.
critics.CrInvalidPseudoStateTrigger-head = Remova Disparador da Transição de \
        Junta de saída
critics.CrInvalidSynch-desc = Este estado de sincronia tem transições \
        inválidas. Normalmente todas as transições de entrada para um estado\
        de sincronia vêm da mesma região e todas as transições de saída para \
        um estado de sincronia vão para a mesma região. Além disso, os \
        contentores dos estados de fonte e destino de transição têm de ser \
        regiões concorrentes.\n\nÉ necessário definir transições válidas para \
        completar a especificação comportamental do seu desenho.\n\nPara \
        corrigir isto, remova transições clicando na transição no diagrama e \
        carregando em \"Ctrl-Delete\". Também pode mudar os estados de fonte e \
        destino das transições.
critics.CrInvalidSynch-head = Mude as Transições de Estados de Sincronia
critics.CrJoinIncomingTransition-desc = O alvo de <ocl>self</ocl> é um \
        Pseudo-estado de Junta mas a sua fonte não é um Estado. Um segmento de \
        junta deve sempre originar de um estado \n\nÉ necessário definir \
        transições válidas para completar a especificação comportamental do \
        seu desenho.\n\nPara corrigir isto, remova esta transição clicando \
        clicando nela no diagrama e carregando em \"Ctrl-Delete\". Também pode \
        mudar os estados de fonte e destino das transições.
critics.CrJoinIncomingTransition-head = Fonte inválida para transição
critics.CrLinkWithoutStimulus-desc = Em diagramas de sequência, um objecto de \
        emissão envia estímulos no objecto receptor sobre uma ligação. A \
        ligação é só uma conexão de comunicação, pelo que é necessário um \
        estímulo.
critics.CrLinkWithoutStimulus-head = Sem Estímulos nestas Ligações
critics.CrMergeClasses-desc = Em classe em foco, <ocl>self</ocl>, só \
        participa numa associação e essa associação é uma associação 1-1 com \
        outra classe. Uma vez que instâncias destas duas classes têm de ser \
        sempre criadas e destruídas juntas, combinar estas classes numa única \
        pode simplificar o seu desenho sem perda de poder de representação. \
        Contudo, pode chegar à conclusão de que a classe combinada é demasiado \
        grande e complexa, pelo que nesse caso ter as classes separadas é \
        geralmente melhor. Organizar classes de modo a gerir a complexidade do \
        desenho é sempre importante, especialmente quando esse desenho já de \
        si é complexo. \n\nPara resolver isto, clique no botão \"Próximo>\", \
        ou adicione manualmente os atributos e operações da classe em foco à \
        outra classe, e por fim remova a classe focada do projecto.
critics.CrMergeClasses-head = Considere Combinar Classes (<ocl>self</ocl>)
critics.CrMissingAttrName-desc = Cada atributo tem de ter um nome.\n\n\
        Nomemclatura clara e não ambígua é um elemento chave da geração de \
        código e torna o desenho muito mais compreensível e fácil de manter.\
        Para resolver isto, use o botão \"Próximo>\", ou seleccione \
        manualmente o atributo e use o separador Propriedades para lhe dar um \
        nome.
critics.CrMissingAttrName-head = Escolha um nome
critics.CrMissingClassName-desc = Cada classe e interface num pacote tem de \
        ter um nome.\n\nNomemclatura clara e não ambígua é um elemento chave \
        da geração de código e torna o desenho muito mais compreensível e \
        fácil de manter. Para resolver isto, use o botão \"Próximo>\", ou \
        seleccione manualmente a classe e use o separador Propriedades para \
        lhe dar um nome.
critics.CrMissingClassName-head = Escolha um nome
critics.CrMissingOperName-desc = Cada operação tem de ter um nome. \n\n\
        Nomemclatura clara e não ambígua é um elemento chave da geração de \
        código e torna o desenho muito mais compreensível e fácil de manter.\n\
        \n Para resolver isto, use o botão \"Próximo>\", ou seleccione \
        manualmente a operação e use o separador Propriedades para lhe dar um \
        nome.
critics.CrMissingOperName-head = Escolha um nome
critics.CrMissingStateName-desc = Cada estado numa máquina de estados deve ter \
        um nome.\n\nNomemclatura clara e não ambígua é um elemento chave da \
        geração de código e torna o desenho muito mais compreensível e fácil \
        de manter.\n\nPara resolver isto, use o botão \"Próximo>\", ou \
        seleccione manualmente o estado e use o separador Propriedades para \
        lhe dar um nome, ou ainda seleccione o estado e escreva o nome.
critics.CrMissingStateName-head = Escolha um nome
critics.CrMultiComposite-desc = Uma instância não pode pertencer por \
        composição a mais de que uma instância composta. Tem de mudar a \
        multiplicidade na ponta de composição da associação para 0..1 ou 1..1 \
        para que o seu modelo faça sentido.\r\n\r\nLembre-se de que a \
        composição é mais forte de que a agregação. O problema pode ser \
        comparado por analogia a um modelo em que um dedo pode fazer parte \
        integrada de mais que uma mão em simultâneo.\r\n\r\nTrata-se da \
        segunda regra de bem-formação de uma ponta de associação em UML 1.4.
critics.CrMultiComposite-head = Ponta de Associação Composta com \
        Multiplicidade > 1
critics.CrMultipleAgg-desc = Só um único fim de uma Associação binária pode \
        ser agregado ou composto.\n\nA agregação e a composição são usadas \
        para indicar relação de parte-todo, e por definição, a ponta \"parte\" \
        não pode ser agregada.\n\nPara resolver isto, seleccione \"Próximo>\" \
        para usar o assistente, ou seleccione manualmente a Associação e \
        defina alguns dos seus papeis de agregação para Nenhum.
critics.CrMultipleAgg-head = Duas Pontas de Agregação (Papeis) numa Associação \
        Binária.
critics.CrMultipleDeepHistoryStates-desc = Existem mútiplos estados de \
        história profunda ambíguos nesta máquina ou estado composto. \
        Normalmente cada máquina de estados ou estado composto só tem um único \
        estado de história profunda.\n\nÉ necessário definir estados de \
        história não ambíguos de forma a completar a parte de especificação \
        comportamental do seu desenho.\n\nPara corrigir isto, seleccione um \
        dos estados de história profunda e apague-o, carregando em \
        \"Ctrl-Delete\".
critics.CrMultipleDeepHistoryStates-head = Remova Estados de História Profunda \
        a mais
critics.CrMultipleInheritance-desc = <ocl>self</ocl> tem múltiplas classes \
        base, mas o Java não suporta herança múltipla. Para tal, terá de usar \
        interfaces.\n\nEsta mudança é obrigatória antes que possa gerar código \
        Java.\n\nPara resolver isto, use o botão \"Próximo>\", ou manualmente: \
        (1) remova uma das classes base e depois (2) opcionalmente defina uma \
        interface com as mesmas declarações de métodos e (3) adicione-a como \
        uma interface de <ocl>self</ocl>, e (4) mova os corpos dos métodos \
        da classe de base antiga para <ocl>self</ocl>.
critics.CrMultipleInheritance-head = Mude Herança Múltipla para Interfaces
critics.CrMultipleInitialStates-desc = Existem múltiplos estados iniciais \
        ambíguos nesta máquina de estados ou estado composto. Normalmente cada \
        máquina de estados ou estado composto só tem um estado inicial.\n\nÉ \
        necessário definir estados não ambíguos de forma a completar a \
        parte de especificação comportamental do seu desenho.\n\nPara resolver \
        isto, carregue no botão \"Próximo>\", or seleccione manualmente um dos \
        estados iniciais a mais e remova-o.
critics.CrMultipleInitialStates-head = Remova Estados Iniciais a mais
critics.CrMultipleRealization-desc = <ocl>self</ocl> implementa múltiplas \
        interfaces. Embora isto seja válido em UML este código não irá \
        compilar em Java. Substitua as múltiplas realizações com \
        generalizações se quiser criar código compilável e livre de erros.
critics.CrMultipleRealization-head = Mude Realização Múltipla em \
        <ocl>self</ocl> para Generalizações
critics.CrMultipleShallowHistoryStates-desc = Existem mútiplos estados de \
        história superficial ambíguos nesta máquina ou estado composto. \
        Normalmente cada máquina de estados ou estado composto só tem um único \
        estado de história superficial.\n\nÉ necessário definir estados de \
        história não ambíguos de forma a completar a parte de especificação \
        comportamental do seu desenho.\n\nPara corrigir isto, seleccione um \
        dos estados de história superficial e apague-o, carregando em \
        \"Ctrl-Delete\".
critics.CrMultipleShallowHistoryStates-head = Remova Estados de História \
        Superficial a mais
critics.CrNWayAgg-desc = Associações ternárias (ou mais) não podem ter pontas \
        de associação (papeis) agregadas.\n\nA agregação e composição são \
        usadas para indicar relação de parte-todo, e por definição só se \
        aplicam a associações binárias entre artefactos.\n\nPara resolver isto \
        , seleccione manualmente a associação e defina a agregação de cada uma \
        das suas pontas (papeis) para Nenhum.
critics.CrNWayAgg-head = Ponta de Agregação (Papel) em Associação Ternária (ou \
        mais).
critics.CrNameConflict-desc = Nomes de elementos contidos num nome de espaços \
        (por exemplo, pacotes) têm de ser únicos. O elemento <ocl>self</ocl> \
        viola esta condição. Esta condição não se aplica para nomes de \
        Associações ou Generalizações.
critics.CrNameConflict-head = Conflito de Nomes Causado por <ocl>self</ocl>
critics.CrNameConflictAC-desc = Nomes de papeis de associação de classe \
        associativa não podem entrar em conflito com nomes de funcionalidades \
        estruturais (por exemplo, variáveis de instância) da classe.
critics.CrNameConflictAC-head = Nome de Papel entra em Conflito com Membro
critics.CrNameConfusion-desc = Os nomes devem ser claramente distintos uns dos \
        outros. Estes dois nomes são tão parecidos um com o outro, que \
        pessoas que lêem o código podem ficar confusas.\n\nNomemclatura clara \
        e não ambígua é o elemento chave da geração de código e torna o \
        desenho muito mais compreensível e fácil de manter. \n\nPara resolver \
        isto, use o botão \"Próximo>\", ou seleccione manualmente os elementos \
        e use o separador das Propriedades para mudar-lhes o nome. Evite nomes \
        que difiram de outros nomes apenas na capitalização dos caracteres, ou \
        sublinha, or por apenas um caracter.
critics.CrNameConfusion-head = Reveja o Nome para Evitar Confusão
critics.CrNavFromInterface-desc = Associações que envolvam uma interface não \
        podem ser navegaveis na direcção da interface. Isto acontece pelo \
        facto de que as interfaces só podem conter declarações de operações e \
        não podem ter apontadores para outros objectos.\n\nEsta parte do \
        desenho deve ser mudada antes de ser usada para gerar código. Código \
        gerado sem resolver este problema não vai de encontro ao desenho \
        pretendido.\n\nPara resolver isto, seleccione a associação e use o \
        separador \"Propriedades\" para seleccionar por sua vez cada ponta de \
        de associação que NÃO está ligada à interface. Desmarque \"Navegável\" \
        para cada uma dessas pontas.\n\nA associação deve então ficar com a \
        aparência de uma seta apontada para a interface.\n\nNOTA. O ArgoUML \
        não deve permitir a criação de associações que são navegáveis a partir \
        de interfaces.\n\nAVISO. A versão corrente do ArgoUML tem um defeito \
        conhecido onde cria uma associação entre uma classe e interface que é \
        navegável nas duas direcções, ou somente da interface para a classe. \
        Se esta a critica for disparada, a correcção passa por remover a \
        navegação da ponta da associação do lado daclasse, e se necessário, \
        adicionar navegação na ponta do lado da interface.
critics.CrNavFromInterface-head = Remova a Navegação de Interface via a \
        Associação <ocl>self</ocl>
critics.CrNoAssociations-desc = Ainda não especificou nenhuma associação para \
        <ocl>self</ocl>. Normalmente as classes, actores e casos de utilização \
        estão associados com outros.\n\nDefinir as associações entre objectos \
        é uma parte importante do seu desenho.\n\nPara resolver isto, carregue \
        no botão \"Próximo>\", ou adicione associações manualmente clicando na \
        ferramenta de associação na barra de ferramentas e arrastando de \
        <ocl>self</ocl> para outro nó.
critics.CrNoAssociations-head = Adicione Associações a <ocl>self</ocl>
critics.CrNoGuard-desc = A Transposição em foco é incompleta porque não tem \
        condição de guarda. Condições de guarda têm de ser verdadeiras para a \
        transição ocorrer. \n\nEste problema tem de ser resolvido de modo a \
        completar a máquina de estados.\n\nPara resolver isto, seleccione a \
        Transição e use o separador \"Propriedades\", ou seleccione a \
        Transição e escreva algum texto na forma:\n[CONDIÇÃO-DE-GUARDA]\nOnde \
        CONDIÇÃO-DE-GUARDA é uma expressão booleana.
critics.CrNoGuard-head = Adicione Condição de Guarda à Transição
critics.CrNoIncomingTransitions-desc = O estado <ocl>self</ocl> não tem \
        transições de entrada. Normalmente, os estados têm transições de \
        entrada e saída.\n\nÉ necessário definir transições de estado \
        completas de forma a completar a parte de especificação comportamental \
        do seu desenho. Sem transições de entrada, este estado não é alcançável\
        .\n\nPara resolver isto, carregue no botão \"Próximo>\", ou adicione \
        transições manualmente clicando na ferramente de transição na barra de \
        ferramentas e arrastando de outro estado para <ocl>self</ocl>.
critics.CrNoIncomingTransitions-head = Adicione Transições de Entrada a \
        <ocl>self</ocl>
critics.CrNoInitialState-desc = Não existe nenhum estado inicial nesta máquina \
        de estados ou estado composto. Normalmente cada máquina de estados ou \
        estao composto tem um estado inicial.\n\nÉ necessário definir estados \
        não ambíguos de forma a completar a parte da especificação \
        comportamental do seu desenho.\n\nPara resolver isto, carregue no \
        botão \"Próximo>\", ou seleccione manualmente estado inicial da barra \
        de ferramentas e coloque-a no diagrama.
critics.CrNoInitialState-head = Coloque um Estado Inicial
critics.CrNoInstanceVariables-desc = Ainda não especificou variáveis de \
        instância para <ocl>self</ocl>. Normalmente as classes têm variáveis \
        de instância que armazenam a informação do estado de cada instância. \
        Classes que só tenham atributos e métodos estáticos devem ser \
        estereótipadas com <<utility>>.\n\nÉ necessário definir variáveis de \
        instância de modo a completar a parte de representação de informação \
        do seu desenho.\n\nPara resolver isto, carregue no botão \"Próximo>\", \
        ou adicione variáveis de instância com um duplo clique em \
        <ocl>self</ocl> na zona de navegação e usando o menu \"Criar\" para \
        fazer um novo atributo.
critics.CrNoInstanceVariables-head = Adicione Variáveis de Instância a \
        <ocl>self</ocl>
critics.CrNoOperations-desc = Ainda não especificou operações para \
        <ocl>self</ocl>. Normalmente as classes têm operações que definem o \
        seu comportamento.\n\nÉ necessário definir operações de modo a \
        completar a parte de especificação comportamental do seu desenho.\n\n\
        Para resolver isto, carregue no botão \"Próximo>\", ou adicione \
        operações manualmente clicando em <ocl>self</ocl> na zona de navegação \
        e usando o menu \"Criar\" para fazer uma nova operação.
critics.CrNoOperations-head = Adicione Operações a <ocl>self</ocl>
critics.CrNoOutgoingTransitions-desc = O estado <ocl>self</ocl> não tem \
        transições de saída. Normalmente, os estados têm transições de \
        entrada e saída.\n\nÉ necessário definir transições de estado \
        completas de forma a completar a parte de especificação comportamental \
        do seu desenho. Sem transições de saída, este estado é um estado \
        \"morto\", pois não tem saída.\n\nPara resolver isto, carregue no \
        botão \"Próximo>\", ou adicione transições manualmente clicando na \
        ferramenta de transição na barra de ferramentas e arrastando de \
        <ocl>self</ocl> para outro estado.
critics.CrNoOutgoingTransitions-head = Adicione Transições de Saída de \
        <ocl>self</ocl>
critics.CrNoTransitions-desc = O estado <ocl>self</ocl> não tem \
        transições de entrada nem de saída. Normalmente, os estados têm \
        transições de entrada e saída.\n\nÉ necessário definir transições de \
        estado completas de forma a completar a parte de especificação \
        comportamental do seu desenho. \n\nPara resolver isto, carregue no \
        botão \"Próximo>\", ou adicione transições manualmente clicando na \
        ferramenta de transição na barra de ferramentas e arrastando de \
        <ocl>self</ocl> para outro estado ou de outro estado para \
        <ocl>self</ocl>.
critics.CrNoTransitions-head = Adicione Transições a <ocl>self</ocl>
critics.CrNoTriggerOrGuard-desc = A Transição em foco está incompleta porque \
        não tem nenhum disparador ou condição de guarda. Os Disparadores são \
        eventos que causam que uma transição se dê. Condições de guarda têm de \
        ser verdadeiras para que a transição se dê. Se só a condição de guarda \
        é usada, então a transição sucede quando a condição fica verdadeira. \
        \n\nEste problema tem de ser resolvido para completar a máquina de \
        estados.\n\nPara resolver isto, seleccione a Transição e use o \
        separador \"Propriedades\", ou seleccione a Transição e escreva algum \
        texto na seguinte forma:\nDISPARADOR [CONDIÇÃO-DE-GUARDA] / ACÇÃO\n\
        Onde DISPARADOR é o nome de um evento, CONDIÇÃO-DE-GUARDA é uma \
        expressão booleana e ACÇÃO é uma acção para ser desempenhada quando a \
        Transição se dá. Todas estas três partes são opcionais.
critics.CrNoTriggerOrGuard-head = Adicione Disparador ou Condição de Guarda à \
        Transição
critics.CrNodeInsideElement-desc = Os Nós normalmente não se encontram dentro \
        de outros Elementos. Eles representam objectos fisicos em tempo de \
        execução com recursos, geralmente com pelo menos uma memória mas \
        também muitas vezes com capacidade de processamento.
critics.CrNodeInsideElement-head = Os Nós Geralmente Não Estão Contidos
critics.CrNodeInstanceInsideElement-desc = As instâncias de Nós normalmente \
        não se encontram dentro de outros Elementos. Eles representam objectos \
        fisicos em tempo de execução com recursos, geralmente com pelo menos \
        uma memória mas também muitas vezes com capacidade de processamento.
critics.CrNodeInstanceInsideElement-head = As Instâncias de Nós Geralmente Não \
        Estão Contidas
critics.CrNodesOverlap-desc = Alguns dos objectos neste diagrama sobrepõem-se, \
        obscurecendo-se uns aos outros. Podem estar a esconder informção \
        importante, tornando-se dificil de entender para os humanos. Uma \
        aparência agradável também pode tornar os seus diagramas mais \
        influentes para outros desenhadores, implementadores e tomadores de \
        decisão.\n\nConstruir um conjunto de diagramas de classes \
        compreensível é uma parte importante do seu desenho.\n\nPara resolver \
        isto, mova os nós focados no diagrama.
critics.CrNodesOverlap-head = Limpe o Diagrama <ocl>self</ocl>
critics.CrNonAggDataType-desc = Os Tipos de Dados não são classes completas e \
        não podem ser associados com classes, excepto se o Tipo de Dados faz \
        parte de uma composição (losangulo negro).\n\nUm bom desenho OO \
        depende das escolhas cuidadosas acerca de quais entidades representar \
        como objectos completos e quais representar como atributos de objectos\
        .\n\nPara resolver isto, carregue no botão \"Próximo>\", ou substitua \
        manualmente o Tipo de Dados por uma classe completa ou mude a \
        associação de agregação para ser contida por uma classe completa.
critics.CrNonAggDataType-head = Encapsule o Tipo de Dados
critics.CrObjectWithoutComponent-desc = Em Diagramas de Instalação os objectos \
        encontram-se normalmente dentro de componentes ou instâncias de \
        componentes.
critics.CrObjectWithoutComponent-head = Os Objectos Estão Normalmente Dentro \
        de Componentes
critics.CrOperNameConflict-desc = Duas operações em <ocl>self</ocl> têm \
        exactamente a mesma assinatura. As Operações têm de ter assinaturas \
        distintas. Uma assinatura é a combinação do nome de uma operação e \
        tipos de parâmetros (excluíndo parâmetros de retorno).\n\nAssinaturas \
        ambiguas reduzem a clareza e introduzem o pontencial para \
        processamento incorrecto. Além disso, não é possível gerar código para \
        as linguagens convencionais OO.\n\nPara resolver isto, seleccione uma \
        das operações em conflito nesta classe e mude o seu nome ou parâmetros.
critics.CrOperNameConflict-head = Mude Nomes de Operação ou Assinaturas em \
        <ocl>self</ocl>
critics.CrOppEndConflict-desc = Dois papeis de <ocl>self</ocl> têm o mesmo \
        nome. Os papeis têm de ter nomes distintos. \n\nNomemclatura clara e \
        não ambígua é o elemento chave da geração de código e torna o desenho \
        muito mais compreensível e fácil de manter.\n\nPara resolver isto, \
        carregue no botão \"Próximo>\", ou seleccione manualmente um dos \
        papeis em conflito na ponta da associação desta classe e mude o seu \
        nome.
critics.CrOppEndConflict-head = Renomeie os Papeis da Associação
critics.CrOppEndVsAttr-desc = Dois atributos não podem ter o mesmo nome dentro \
        de um Classificador.\n\nTrata-se de segunda regra de boa formação de \
        Classificador em UML 1.4.
critics.CrOppEndVsAttr-head = Renomeio Papel ou Atributo
critics.CrParamTypeNotImported-desc = O tipo de cada parametro da operação tem \
        de ser visível e importado para a classe que contem a operação.\n\n\
        A importação de classes é necessária para a geração de código. Boa \
        modularização de classes em pacotes é a chave para um desenho \
        compreensível.\n\nPara resolver isot, use o botão \"Próximo\", ou \
        adicione manualmente uma importação à classe que contem esta operação.
critics.CrParamTypeNotImported-head = Importe Tipo do Parâmetro para a Classe
critics.CrReservedName-desc = \"<ocl>self</ocl>\" é uma palavra reservada ou \
        muita parecida a uma. Os nomes dos elementos de modelo não podem \
        entrar em conflito com palavras reservadas de linguagens de \
        programação ou UML.\n\nA utilização de nomes válidos é necessária para \
        gerar código compilável.\n\nPara resolver isto, use o botão \
        \"Próximo>\", ou seleccione manualmente o elemento focado e use o \
        separador das Propriedades para lhe atribuir um nome diferente.
critics.CrReservedName-head = Mude <ocl>self</ocl> para uma Palavra Não \
        Reservada
critics.CrReturnWithoutCall-desc = Cada acção de retorno requere uma acção de \
        chamada ou envio, mas esta Ligação não tem nenhuma acção correspondente.
critics.CrReturnWithoutCall-head = Acção de Chamada(Envio) em Falta
critics.CrSeqInstanceWithoutClassifier-desc = Instâncias têm um Classificador.
critics.CrSeqInstanceWithoutClassifier-head = Defina Classificador
critics.CrSingletonViolatedMissingStaticAttr-desc = <ocl>self</ocl> está \
        marcada com o estereótipo <<singleton>>, mas não satisfaz as \
        restrições impostas em \"Singletons\".\nNão tem um atributo estático \
        (uma variável de classe) para conter a instância.\n\nSempre que marca \
        uma classe com um estereótipo, a classe deve satisfazer todas as \
        restrições do estereótipo. Isto é uma parte importante em termos de \
        fazer um desenho compreensível e consistente. Usar o Padrão \
        \"Singleton\" pode salvar tempo e espaço de memória.\n\nSe já não \
        pretende que esta classe seja \"Singleton\", remova o estereótipo \
        clicando na classe e seleccionando a selecção a vazio no drop-down que \
        se encontra no separador das propriedades.
critics.CrSingletonViolatedMissingStaticAttr-head = Estereótipo Singleton \
        Violado, Falta Atributo Estático em <ocl>self</ocl>
critics.CrSingletonViolatedOnlyPrivateConstructors-desc = <ocl>self</ocl> está \
        marcada com o estereótipo <<singleton>>, mas não satisfaz as \
        restrições impostas em \"Singletons\".\nSó pode ter constructores \
        privados, de modo a que novas instâncias não possam ser feitas por \
        outro código. \n\nSempre que marca uma classe com um estereótipo, a \
        classe deve satisfazer todas as restrições do estereótipo. Isto é uma \
        parte importante em termos de fazer um desenho compreensível e \
        consistente. Usar o Padrão \"Singleton\" pode salvar tempo e espaço de \
        memória.\n\nSe já não pretende que esta classe seja \"Singleton\", \
        remova o estereótipo clicando na classe e seleccionando a selecção a \
        vazio no drop-down que se encontra no separador das propriedades.
critics.CrSingletonViolatedOnlyPrivateConstructors-head = Estereótipo \
        Singleton Violado, Tem Constructor Não Privado em <ocl>self</ocl>
critics.CrStimulusWithWrongPosition-desc = Em diagramas de sequência o lado \
        emissor das conexões de comunicação destes estímulos estão ligadas \
        no inicip de uma activação. Para ser um emissor, um objecto tem de ter \
        um foco de controlo primeiro.
critics.CrStimulusWithWrongPosition-head = Posição Incorrecta destes Estímulos
critics.CrSubclassReference-desc = A classe <ocl>self</ocl> tem uma referência \
        para uma das suas sub-classes. Normalmente todas as sub-classes devem \
        ser tratadas de modo igual pela super-classe. Isto permite a adição de \
        novas sub-classes sem modificação da super-classe.\n\nA difinição de \
        associações entre objectos é uma parte importante do ser desenho. \
        Alguns padrões de associações são mais fáceis de manter que outros, \
        dependendo da natureza das mudanças futuras.\n\nPara resolver isto, \
        carregue no botão \"Próximo\", ou remova a associação manualmente \
        clicando nela no diagrama e na tecla Delete.
critics.CrSubclassReference-head = Remova Referência a Sub-Classe Específica
critics.CrTooManyAssoc-desc = Existem demasiadas Associações na classe \
        <ocl>self</ocl>. Sempre que uma classe se torna demasiado central ao \
        desenho, pode-se tornar um \"gargalo\" que tem de ser actulizado \
        frequentemente.\n\nDefinir as associações entre objectos é uma parte \
        importante do seu desenho.\n\nPara resolver isto, carregue no botão \
        \"Próximo>\", ou remova associações manualmente clicando em uma \
        associação na zona do Navegador ou diagrama, e carregando na tecla Delete.
critics.CrTooManyAssoc-head = Reduza o Número de Associações em <ocl>self</ocl>
critics.CrTooManyAttr-desc = Existem demasiados atributos em <ocl>self</ocl>. \
        Sempre que uma classe se torna demasiado central ao desenho, pode-se \
        tornar um \"gargalo\" que tem de ser actualizado frequentemente.\n\n\
        Definir os atributos dos objectos é uma parte importante do seu \
        desenho.\n\nPara resolver isto, carregue no botão \"Próximo>\", ou \
        remova atributos manualmente clicando no compartimento de atributos da \
        classe em foco no diagrama, e remova a linha de texto de um atributo.
critics.CrTooManyAttr-head = Reduza o Número de Atributos on <ocl>self</ocl>
critics.CrTooManyClasses-desc = Existem demasiadas classes em <ocl>self</ocl>. \
        Se um diagrama de classes tem demasiadas classes pode-se tornar muito \
        dificil de ler por humanos.\n\nA definição de um conjunto \
        compreensível de diagramas de classes é uma parte importante do seu \
        desenho. \n\nPara resolver isto, carregue no botão \"Próximo\", ou \
        remova classes manualmente clicando numa classe na zona do Navegador ou \
        diagrama, e carregando na tecla \"Delete\". Ou pode fazer um novo \
        diagrama...
critics.CrTooManyClasses-head = Reduza Classes em <ocl>self</ocl>
critics.CrTooManyOper-desc = Existem demasiadas operações na classe \
        <ocl>self</ocl>. Sempre que uma classe se torna demasiado central ao \
        desenho, pode-se tornar um \"gargalo\" que tem de ser actualizado \
        frequentemente. \n\nA definição das operações de objectos é uma parte \
        importante do seu desenho.\n\nPara resolver isto, carregue no botão \
        \"Próximo>\" ou remova manualmente operações com um duplo clique no \
        compartimento de operação da classe focada no diagrama e removendo a \
        linha de texto de uma operação.
critics.CrTooManyOper-head = Reduza o Número de Operações em <ocl>self</ocl>
critics.CrTooManyStates-desc = Existem demasiados estados em <ocl>self</ocl>. \
        Se uma máquina de estado tem demasiados estados, pode-se tornar muito \
        dificil de compreender por humanos.\n\nA definição de conjunto de \
        classes compreensível é uma parte importante do seu desenho.\n\nPara \
        resolver isto, carregue no botão \"Proximo\", ou remova estados \
        manualmente clicando em estados na zona do Navegador ou diagrama, e \
        carregando na tecla \"Delete\". Ou pode aninhar estados...
critics.CrTooManyStates-head = Reduza o Número de Estados na Máquina \
        <ocl>self</ocl>
critics.CrTooManyTransitions-desc = Existem demasiadas Transições no estado \
        <ocl>self</ocl>. Sempre que um estado se torna demasiado central à \
        máquina pode-se tornar um \"gargado\"de manutenção que tem de ser \
        actualizado frequentemente.\n\nA definição de transições entre estados \
        é uma parte importante do seu desenho.\n\nPara resolver isto, carregue \
        no botão \"Próximo\", ou remova transições manualmente clicando numa \
        transição na zona do Navegador ou diagrama e carregando na tecla \
        \"Delete\".
critics.CrTooManyTransitions-head = Reduza o Número de Transições em \
        <ocl>self</ocl>
critics.CrUnconventionalAttrName-desc = Normalmente os nomes de atributos \
        começam com uma letra minúscula. O nome '<ocl>self</ocl>' é pouco \
        convencional porque não cumpre essa regra.\n\nSeguir boas convenções \
        de nomes ajuda a melhorar a compreensão e manutenção do desenho. \n\n\
        Para resolver isto, use o botão \"Próximo>\", ou seleccione \
        manualmente <ocl>self</ocl> e use o separador Propriedades para lhe \
        atribuir um nome diferente.
critics.CrUnconventionalAttrName-head = Escolha um Nome de Atributo Melhor
critics.CrUnconventionalClassName-desc = Normalmente os nomes das classes \
        começam por uma letra maiuscula. O nome '<ocl>self</ocl>' é pouco \
        convencional porque não cumpre essa regra.\n\nSeguir boas convenções \
        de nomes ajuda a melhorar a compreensão e manutenção do desenho. \n\n\
        Para resolver isto, use o botão \"Próximo>\", ou seleccione \
        manualmente <ocl>self</ocl> e use o separador Propriedades para lhe \
        atribuir um nome diferente.
critics.CrUnconventionalClassName-head = Escolha um Nome de Classe Melhor
critics.CrUnconventionalOperName-desc = Normalmente os nomes de operações \
        começam com uma letra minúscula. O nome '<ocl>self</ocl>' é pouco \
        convencional porque não cumpre essa regra.\n\nSeguir boas convenções \
        de nomes ajuda a melhorar a compreensão e manutenção do desenho. \n\n\
        Para resolver isto, use o botão \"Próximo>\", ou seleccione \
        manualmente <ocl>self</ocl> e use o separador Propriedades para lhe \
        atribuir um nome diferente.
critics.CrUnconventionalOperName-head = Escolha um Nome de Operação Melhor
critics.CrUnconventionalPackName-desc = Normalmente os nomes de pacotes são \
        escritos em minúsculas com pontos a indicar pacotes aninhados. O nome \
        '<ocl>self</ocl>' é pouco convencional porque não cumpre essa regra.\
        \n\nSeguir boas convenções de nomes ajuda a melhorar a compreensão e \
        manutenção do desenho.\n\nPara resolver isto, use o botão \"Próximo>\"\
        , ou seleccione manualmente <ocl>self</ocl> e use o separador \
        Propriedades para lhe atribuir um nome diferente.
critics.CrUnconventionalPackName-head = Reveja o Nome de Pacote <ocl>self</ocl>
critics.CrUnnavigableAssoc-desc = A Associação <ocl>self</ocl> não é navegável \
        em qualquer direcção. Todas as associações devem ser navegáveis em \
        pelo menos um sentido.\n\nDefinir a navegabilidade das associações \
        permite ao código aceder a dados através de apontadores.\n\nPara \
        resolver isto, seleccione a associação \"<ocl>self</ocl>\" no diagrama \
        ou painel Navegação e clique no separador Propriedades. Depois use as \
        caixas de marcação no fundo do painel para activar a navegabilidade.
critics.CrUnnavigableAssoc-head = Fala <ocl>self</ocl> Navegável
critics.CrUselessAbstract-desc = <ocl>self</ocl> nunca consegue influenciar o \
        sistema em execução porque não pode ter instâncias, nem nenhuma das \
        suas sub-classes podem ter instâncias.\n\nPara resolver este problema: \
        (1) defina sub-classes concretas que implementem a interface da sua \
        classe; ou (2) faça <ocl>self</ocl> ou uma das suas sub-classes \
        existentes concretas.
critics.CrUselessAbstract-head = Defina (Sub-)Classes Concretas
critics.CrUselessInterface-desc = <ocl>self</ocl> nunca pode ser usadas porque \
        nenhuma classe a implementa.\n\nPara resolver este problema, carregue \
        no botão \"Next>\" ou manualmente use o botão \"Classe\" da barra de \
        ferramentas para definir classes e o botão \"Realiza\" para criar uma \
        relação da classes para a interface focada.
critics.CrUselessInterface-head = Defina uma Classe que Implemente \
        <ocl>self</ocl>
critics.CrUtilityViolated-desc = <ocl>self</ocl> está marcada com o \
        estereótipo <<utility>>, mas não satisfaz as restrições impostas aos \
        Utilitários. Não tem atributos de instância, variáveis ou operações.\
        \n\nSe já não quer que esta classe seja um Utilitário, remova o \
        estereótipo clicando na classe e seleccionando a selecção a vazio no \
        drop-down dentro do separador Propriedades.
critics.CrUtilityViolated-head = Estereótipo Utilitário Violado, Podem ser \
        Criadas Instâncias
critics.CrWrongLinkEnds-desc = Em diagramas de instalação os objectos podem \
        residir ou em componentes ou em instâncias de componente. Assim não é \
        possível ter dois objectos ligados através de uma Ligação, enquando um \
        objecto reside num componente e um outro objecto numa instância de um \
        componente.\n\nPara resolver isto, remova da sua localização um \
        objecto dos dois ligados para um elemento que tenha o mesmo tipo que a \
        localização do outro objecto.
critics.CrWrongLinkEnds-head = Pontas de Ligação Não Têm as Mesmas Localizações
critics.CrZeroLengthEdge-desc = Esta aresta é demasiada pequena para ser \
        vista com facilidade. Isto pode ocultar informação importante e tornar \
        dificil de entender por humanos. Uma aparência agradável pode também \
        tornar os seus diagramas mais influentes em outros desenhadores, \
        implementadores, e tomadores de decisão.\n\nConstruir um conjunto de \
        diagramas compreensível e fácil de manter é uma parte importante do \
        seu desenho. \n\nPara resolver isto, mova um ou mais nós de modo a que \
        as arestas focadas sejam longos, ou clique no centro de uma aresta e \
        arraste-a para fazer um novo vértice.
critics.CrZeroLengthEdge-head = Torne a Aresta Mais Visível
