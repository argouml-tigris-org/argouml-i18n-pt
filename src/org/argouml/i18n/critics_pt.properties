# $Id$
# Based on critics.properties,v 1.14.
# Copyright (c) 2005, 2006 The Regents of the University of California. All
# Rights Reserved. Permission to use, copy, modify, and distribute this
# software and its documentation without fee, and without a written
# agreement is hereby granted, provided that the above copyright notice
# and this paragraph appear in all copies.  This software program and
# documentation are copyrighted by The Regents of the University of
# California. The software program and documentation are supplied "AS
# IS", without any accompanying services from The Regents. The Regents
# does not warrant that the operation of the program will be
# uninterrupted or error-free. The end-user understands that the program
# was developed for research purposes and is advised not to rely
# exclusively on the program for any reason.  IN NO EVENT SHALL THE
# UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
# SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
# UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
#
# Created from UMLCognitiveResourceBundle.java
#
# The keys are generated from the class names of the classes that use them.
#
critics.CrAlreadyRealizes-desc = A classe seleccionada já concretiza \
        indirectamente a Interface {item.extra}.  Não há necessidade de \
        realizar directamente outra vez.\n\nSimplificar o Desenho é sempre boa \
        ideia. Pode ignorar este item \"por fazer\" se quiser tornar explicito \
        de que a Classe selecionada realiza esta Interface.\n\nPara resolver \
        isto , selecione a Realização (linha tracejada com seta triangular \
        branca) e pressione a combinação de teclas \"Ctrl-Delete\".
critics.CrAlreadyRealizes-head = Remova Realizações desnecessárias de \
        <ocl>self</ocl>
critics.CrAssocNameConflict-desc = Cada elemento de um espaço de nomes tem de \
        um nome único. \n\nNomemclatura clara e não ambígua é o elemento chave \
        da geração de código e torna o desenho muito mais compreensível e \
        fácil de manter. \n\nPara resolver isto, use o botão \"Próximo>\", ou \
        seleccione manualmente os elementos e use o separador das Propriedades \
        para mudar os seus nomes.
critics.CrAssocNameConflict-head = Resolva Conflito de Nome de Associação
critics.CrAttrNameConflict-desc = Os atributos têm de ter nomes distintos. \
        Esta crítica pode ter sido dispoletada como resultado de um nome de \
        atributo herdado. \n\nNomemclatura clara e não ambígua é o elemento \
        chave da geração de código e torna o desenho muito mais compreensível \
        e fácil de manter. \n\nPara resolver isto, use o botão \"Próximo>\", \
        ou seleccione manualmente um dos atributos em conflito desta classe e \
        mude o seu nome.
critics.CrAttrNameConflict-head = Reveja os Nomes de Atributos para Evitar \
        Conflito
critics.CrCallWithoutReturn-desc = Cada chamada ou acção de envio requere uma \
        acção de retorno,\n mas esta Ligação não tem nenhuma acção de retorno.
critics.CrCallWithoutReturn-head = Acções de Retorno em Falta
critics.CrCircularAssocClass-desc = Classes Associativas não podem incluír \
        papeis que referem directamente de volta à Classe Associativa.
critics.CrCircularAssocClass-head = Associação Circular
critics.CrCircularComposition-desc = Relações de Composição (losangulos \
        pretos) não podem ter ciclos. \n\nUma hierarquia de agregação legal \
        é necessária para a geração de código e correcção do desenho. \n\nPara \
        resolver isto, use o botão \"Próximo>\", ou seleccione manualmente uma \
        das associações no ciclo e remova-a ou mude a sua agregação para algo \
        que não seja composto.
critics.CrCircularComposition-head = Remova Composição Circular
critics.CrCircularInheritance-desc = Relações de Herança não podem ter ciclos \
        \n\nUma hierarquia de heranças legal é necessária para a geração de \
        código e correcção do desenho.
critics.CrCircularInheritance-head = Remova a Herança Circular de \
        <ocl>self</ocl>
critics.CrClassMustBeAbstract-desc = Classes que incluam ou herdem métodos \
        abstractos de classes base ou interfaces têm de estar marcadas como \
        abstractas. \n\nDecidir que classes são abstractas ou concretas é uma \
        parte chave do desenho de hierarquias de classes.\n\nPara corrigir \
        isto, use o botão \"Próximo>\" , ou seleccione manualmente a classe e \
        use o separador de propriedades para adicionar palavra-chave \
        Abstracta, ou implemente manualmente cada operação abstracta que é \
        herdada da classe base ou interface.
critics.CrClassMustBeAbstract-head = A Classe <ocl>self</ocl> Tem De Ser \
        Abstracta
critics.CrClassWithoutComponent-desc = Em Diagramas de Instalação as classes \
        estão normalmente dentro de componentes.
critics.CrClassWithoutComponent-head = As Classes Normalmente Estão Dentro de \
        Componentes
critics.CrCompInstanceWithoutNode-desc = Existem instancias de nós no \
        Diagrama. Assim, tem um Diagrama de Instaçação real, e nestes as \
        instâncias de componentes geralmente residem em instâncias de nós.
critics.CrCompInstanceWithoutNode-head = Instâncias de Componentes \
        Encontram-se Normalmente Dentro De Nós
critics.CrComponentWithoutNode-desc = Existem nós no diagrama. Portanto, \
        tem um Diagrama de Instalação real, e nestes os componentes \
        os componentes normalmente residem nos nós.
critics.CrComponentWithoutNode-head = Os Componentes Normalmente Estão Dentro \
        Dos Nós
critics.CrConflictingComposites-desc = Um papel composto (losangulo preto) \
        de uma associação indica que as instâncias daquela classe contêm \
        instâncias das classes associadas. Uma vez que cada instância só pode \
        estar contida num único objecto, cada objecto pode ser 'parte' de no \
        máximo uma relação é-parte-de.\n\nUm bom desenho OO depende da \
        construção de boas relações é-parte-de.\n\nPara resolver isto, use o \
        botão \"Próximo>\", ou mude manualmente uma associação de modo a ter \
        multiplicidade 0..1 ou 1..1, ou outro tipo de agregação (por exemplo, \
        um losangulo branco é menos restrito), ou remova uma das associações.
critics.CrConflictingComposites-head = Remova Associaçõe Compostas em Conflito
critics.CrConsiderSingleton-desc = <ocl>self</ocl> não tem nenhum atributo \
        não estático nem nenhuma associação que seja navegável a partir das \
        instâncias desta classe. Isto signigica que cada instância desta \
        classe será idêntica a todas as outras instâncias, uma vez que não \
        existirá nada nas instâncias que as diferencie.\n\nNestas \
        circunstâncias deve considerar tornar explicito de que tem exactamente \
        uma única instância desta classe, através do Padrão Singleton. \
        Utilizando o Padrão Singleton pode salvar tempo e espaço de \
        memória. Dentro do ArgoUML is pode ser feito através do estereótipo \
        <<singleton>> nesta classe.\n\nSe não é a sua intenção ter uma única \
        instância, deve definir variáveis de instância (isto é, atributos não \
        estáticos) e/ou associação de saída que irão representar diferenças \
        entre as instâncias. \n\nTendo especificado <ocl>self</ocl> como \
        Singleton, precisa de definir a classe de modo a que só exista uma \
        única instância. Isto irá completar a parte de representação de \
        informação do seu desenho. Para obter isto deverá fazer o seguinte.\n\n\
        1. Defina um atributo estático (uma variável de classe) que contenha a \
        instância. Isto terá portanto <ocl>self</ocl> como tipo.\n\n2. \
        Providencie só constructores privados para <ocl>self</ocl> de modo a \
        que novas instâncias não possam ser feitas por outro código. A criação \
        de uma única instância podia ser obtida através de uma operação \
        ajudante apropriada, que invoca este constructor privado só uma vez. \n\
        \n3. Providencie pelo menos um constructor para sobrepôr o constructor \
        por omissão, de modo a que o constructor por omissão não seja usado \
        para criar multiplas instancias.\n\nNo padrão UML 1.4, um constructor \
        é uma operação com o estereótipo <<create>>.\n\nPor convenção em Java \
        e C++ um constructor tem o mesmo nome que a classea, não é estático, \
        e não retorna nenhum valor. Note que no ArgoUML isto significa que \
        terá de remover o valor de retorno criado por omissão para a operação \
        de constructor.
critics.CrConsiderSingleton-head = Considere Utilizar o Padrão Singleton para \
        <ocl>self</ocl>
critics.CrConstructorNeeded-desc = Ainda não definiu um constructor para a \
        classe <ocl>self</ocl>. Os constructores inicializam novas instâncias \
        de modo a que os seus atributos tenham valores válidos. Provavelmente \
        esta classe precisa de um constructor porque nem todos os seus \
        atributos têm valores iniciais.\n\nDefinir bons constructores é a \
        chave para estabelecer invariantes de classe , e estas são uma ajuda \
        poderosa para escrever código sólido .\n\nPara resolver isto, adicione \
        um constructor manualmente clicando em <ocl>self</ocl> no pane do \
        navegador e adicionando uma operação através do menu pop-up sensível a \
        contexto no separador das propriedades, ou seleccionando \
        <ocl>self</ocl> onde apareça num diagrama de classes e usando a \
        ferramenta \"Adicionar Operação\". Depois use o separador Propriedades \
        no pane Detalhes para seleccionar o estereótipo <<create>> na \
        operação.\n\nUm constructor é uma operação com o estereótipo <<create>>.
critics.CrConstructorNeeded-head = Adicione Constructor a <ocl>self</ocl>
critics.CrCrossNamespaceAssoc-desc = Cada classe, interface ou outro \
        classificador (<ocl>self</ocl>) involvido numa associação deve estar \
        no nome de espaços da associação.\n\nSe não for este o caso, então não \
        haverá maneira das classes, interfaces ou outros classificadores \
        nomearem a referência uns dos outros usando a associação.\n\nNote que \
        esta crítica presentemente não interpreta nomes de espaços \
        hierárquicos. Assim, irá disparar se os componentes finais dos nomes \
        de espaços são diferentes, mesmo que partilhem uma raíz comum, e esta \
        crítica dessa ser interpretada tendo isso em conta.\n\nPara resolver \
        isto, apague a associação e volte a criá-la num diagrama cujo nome de \
        espaços inclua as classes, interfaces e classificadores involvidos.
critics.CrCrossNamespaceAssoc-head = O Classificador <ocl>self</ocl> não está \
        no Nome de Espaços da sua Associação
critics.CrDisambigClassName-desc = Cada classe e interface dentro de um pacote \
        têm de ter um nome único. Existem pelo menos dois elementos neste \
        pacote chamados \"<ocl>self</ocl>\".\n\nNomemclatura clara e não \
        ambígua é um elemento chave na geração de código e torna o desenho \
        mais compreensível e fácil de manter. \n\nPara resolver isto, use o \
        botão \"Próximo>\", ou seleccione manualmente uma das classes em \
        conflito e use o separador Propriedades para mudar os seus nomes.
critics.CrDisambigClassName-head = Escolha um Nome Único para <ocl>self</ocl>
critics.CrDisambigStateName-desc = Cada estado dentro de uma máquina de \
        estados tem de ter um nome único. Existem pelo menos dois estados \
        nesta máquina com o nome \"<ocl>self</ocl>\".\n\nNomemclatura clara e \
        não ambígua é um elemento chave na geração de código e torna o desenho \
        mais compreensível e fácil de manter. \n\nPara resolver isto, use o \
        botão \"Próximo>\", ou seleccione manualmente um dos estados em \
        conflito e use o separador \"Propriedades\" para mudar os seus nomes.
critics.CrDisambigStateName-head = Escolha um Nome Único para <ocl>self</ocl>
critics.CrDupParamName-desc = Cada parâmetro numa operação tem de ter um nome \
        único. \n\nNomemclatura limpa e não ambígua é necessária para a \
        geração de código e para obter desenhos claros e fáceis de manter.\n\n\
        Para resolver isto, use o botão \"Próximo>\", ou mude manualmente o \
        nome de um dos parâmetros desta operação.
critics.CrDupParamName-head = Nome de Parâmetro duplicado
critics.CrDupRoleNames-desc = A Associação <ocl>self</ocl> tem dois (ou mais) \
        papeis com o mesmo nome.\n\nNomemclatura clara e não ambígua é um \
        elemento chave na geração de código e torna o desenho mais \
        compreensível e fácil de manter.\n\nPara resolver isto seleccione \
        <ocl>self</ocl> manualmente e use o separador das Propriedades para \
        mudar um ou mais dos nomes de papeis em conflito.
critics.CrDupRoleNames-head = Nomes de Papeis de Fim duplicados para \
        <ocl>self</ocl>
critics.CrEmptyPackage-desc = Ainda não colocou nada no pacote <ocl>self</ocl>.\
         Normalmente os pacotes contêm grupos de classes relacionadas.\n\n\
        Definir e usar pacote é um elemento chave do desenho viável de manter.\
        \n\nPara resolver isto, seleccione o pacote <ocl>self</ocl> no painel\
        navegador e adicione diagramas ou elementos de modelo tais como \
        classes ou casos de utilização.
critics.CrEmptyPackage-head = Adicione Elementos ao Pacote <ocl>self</ocl>
critics.CrFinalSubclassed-desc = A palavra chave 'leaf' indica que a classe \
        não é suposto ter sub-classes. Esta classe ou interface está marcada \
        como 'leaf' e tem sub-classes.\n\nUma hierarquia de classes bem \
        estruturada que contempla e suporta extensão intencionais é uma parte \
        importante para obter um desenho compreensivel e fácil de manter.\n\n\
        Para resolver isto, use o botão \"Próximo>\", ou seleccione \
        manualmente a classe e mude a sua classe base, ou seleccione a classe \
        basee use o separador das propriedades para remover a palavra-chave \
        'leaf'.
critics.CrFinalSubclassed-head = Remova a Palavra-chave 'Leaf' ou Remova \
        Sub-classes de <ocl>self</ocl>
critics.CrForkOutgoingTransition-desc = A fonte de <ocl>self</ocl> é um \
        Pseudo-estado de Difusão, mas o seu alvo não é um Estado. Um segmento \
        de difusão deve sempre ter como alvo um estado.\n\nÉ necessário \
        definir transições válidas para completar a especificação \
        comportamental do seu desenho.\n\nPara corrigir isto, carregue em \
        remover esta transição clicando na transição do diagrama e carregando \
        em \"Ctrl-Delete\". Também pode mudar a fonte dos estados de transição \
        ou destino.
critics.CrForkOutgoingTransition-head = Alvo inválido para transição
critics.CrIllegalGeneralization-desc = Elementos de modelo só podem ser \
        herdados por outros do mesmo tipo. \n\nUm hierarquia de herança válida \
        é necessária para geração de código e correcção do desenho. \n\nPara \
        resolver isto, use o botão \"Próximo>\", ou seleccione manualmente a \
        seta de generalização e remova-a.
critics.CrIllegalGeneralization-head = Generalização Inválida
critics.CrIllegalName-desc = Os nomes de elementos do modelo têm de ser \
        sequências de letras, numeros, e underscores. Não podem conter \
        pontuação. \n\nA geração de código requere nomes válidos para que o \
        código resultante compile correctamente. \n\nPara resolver isto, \
        seleccione manualmente o elemento em foco e o use o separador \
        Propriedades para lhe dar um nome diferente.
critics.CrIllegalName-head = Escolha um Nome Válido para <ocl>self</ocl>
critics.CrInstanceWithoutClassifier-desc = Instâncias têm um classificador.
critics.CrInstanceWithoutClassifier-head = Defina o Classificador
critics.CrInterfaceAllPublic-desc = As interfaces têm como objectivo \
        especificar o conjunto de operações que as outras classes devem \
        implementar. Têm de ser públicas. \n\nUm conjunto bem desenhado de \
        interfaces é uma boa maneira para definir possíveis extensões a uma \
        infraestrutura de classes. \n\nPara resolver isto, use o botão \
        \"Próximo>\", ou seleccione manualmente as operações da interface e \
        use o separador Propriedades para torná-las públicas.
critics.CrInterfaceAllPublic-head = Operações em Interfaces têm de ser Públicas
critics.CrInterfaceOperOnly-desc = As interfaces têm como objectivo \
        especificar o conjunto de operações que as outras classes devem \
        implementar. Não implementam essas operações propriamente ditas, e não \
        ter atributos. \n\nUm conjunto bem desenhado de interfaces é uma boa \
        maneira para definir possíveis extensões a uma infraestrutura de \
        classes. \n\nPara resolver isto, use o botão \"Próximo>\", ou \
        seleccione manualmente a interface e use o separador Propriedades para \
        remover todos os atributos.
critics.CrInterfaceOperOnly-head = Interfaces só podem ter Operações
critics.CrInterfaceWithoutComponent-desc = Em diagramas de instalação, as \
        interfaces encontram-se normalmente dentro dos componentes.
critics.CrInterfaceWithoutComponent-head = Interfaces estão normalmente dentro \
        de Componentes
critics.CrInvalidBranch-desc = Este estado branch (escolha or junção) tem um \
        número inválido de transições. Normalmente estados branch têm pelo \
        menos uma transição de entrada e pelo menos uma transição de saída. \n\
        \nÉ necessário definir transições de estado correctas de modo a \
        completar a especificação comportamentas do seu desenho. \n\nPara \
        resolver isto, adicione transições através da ferramenta de transições.
critics.CrInvalidBranch-head = Adicione Transições de Escolha/Junção
critics.CrInvalidFork-desc = Este estado de difusão tem um número inválido de \
        transições. Normalmente estados de difusão têm uma transição de \
        entrada e duas ou mais de saída . \n\nÉ necessário definir transições \
        de estado correctas de modo a completar a especificação comportamental \
        do seu desenho. \n\nPara resolver isto, adicione ou remova transições \
        manualmente.
critics.CrInvalidFork-head = Mude as Transições de Difusão
critics.CrInvalidForkTriggerOrGuard-desc = A Transição em foco não deve ter um \
        disparador ou condição de guarda porque é uma transição de saída de um \
        Pseudo-estado de Difusão. As transições que saem de um vértice de \
        difusão não podem ter disparadores ou condições de guarda.\n\nÉ \
        necessário definir transições válidas de modo a completar a \
        corrigir isto, remova o disparador selecionado-o no pane explorador e \
        especificação comportamental do seu desenho.\n\nPara removendo-o do \
        modelo através do menu obtido com um clique direito no rato. Ou, no \
        caso de uma condição de guarda, remova-a com um duplo clique no campo \
        de condição de guarda da transição e carregando em \"Ctrl-Delete\".
critics.CrInvalidForkTriggerOrGuard-head = Remova Disparador ou Condição de \
        Guarda da Transição de Saída Difusa
critics.CrInvalidHistory-desc = Este estado História tem um número inválido \
        de transições. Normalmente os estados de História Superficial e \
        História Profunda têm no máximo um transição de saída. \n\nÉ \
        necessário definir transições de estado correctas de modo a completar \
        a especificação comportamental do seu desenho. \n\nPara corrigir isto, \
        remova transições clicando na transição no diagrama e carregando em \
        \"Ctrl-Delete\".
critics.CrInvalidHistory-head = Remova Transições de Saída a mais
critics.CrInvalidInitial-desc = Este estado inicial tem um número inválido de \
        transições. Normalmente estados iniciais têm no máximo uma transição \
        de saída.\n\nÉ necessário definir transições válidas de modo a \
        completar a especificação comportamental do seu desenho. \n\nPara \
        corrigir isto, remova transições clicando na transição no diagrama e \
        carregando em \"Ctrl-Delete\".
critics.CrInvalidInitial-head = Remova Transições de Saída a mais
critics.CrInvalidJoin-desc = Este estado de junta tem um número inválido de \
        transições. Normalmente estados de junta têm duas ou mais transições \
        de entrada e uma transição de saída. \n\nÉ necessário definir \
        transições de estado correctas de modo a completar a especificação \
        comportamental do seu desenho. \n\nPara  resolver isto, adicione ou \
        remova transições manualmente.
critics.CrInvalidJoin-head = Mude Transições de Junta
critics.CrInvalidJoinTriggerOrGuard-desc = A transição em foco não deve ter um \
        disparador ou condição de guarda porque é uma transição de entrada de \
        um Pseudo-estado de Junta. As transições que entram num vértice de \
        junta não devem ter disparadores ou condições de guarda.\n\nÉ \
        necessário definir transições de estado correctas de modo a completar \
        a especificação comportamental do seu desenho.\n\nPara corrigir isto, \
        remova o disparador selecionando-o no pane explorador e removendo-o do \
        modelo com o menu de clique direito no rato. Ou, no caso de uma \
        condição de guarda, remova-a com um duplo clique no campo de condição \
        de guarda da transição e carregando em \"Ctrl-Delete\".
critics.CrInvalidJoinTriggerOrGuard-desc = A Transição em foco não deve ter um \
        disparador ou condição de guarda porque é um Pseudo-Estado de Junta de \
        uma transição de entrada. As transições que entram num vértice não \
        podem ter disparadores ou condições de guarda.\n\nÉ necessário definir \
        transições válidas para completar a especificação comportamental do \
        seu desenho.\n\nPara corrigir isto, remova o disparador selecionando-o \
        pane explorador e escolhendo a opção \"Remover do Modelo\" no menu que \
        aparece com um clique direito no rato. Ou, no caso de uma condição de \
        guarda, remova-a com um duplo clique no campo de guarda da transição e \
        carregando em \"Ctrl-Delete\".
critics.CrInvalidJoinTriggerOrGuard-head = Remova Disparador ou Condição de \
        Guarda da Transição de Junta de entrada
critics.CrInvalidPseudoStateTrigger-desc = A Transição em foco não deve ter um \
        disparador porque é um Pseudo-Estado de Junta de uma transição de \
        saída. As transições que saem de um pseudo-estado não podem ter \
        disparadores.\n\nÉ necessário definir transições válidas para \
        completar a especificação comportamental do seu desenho.\n\nPara \
        corrigir isto, remova o disparador seleccionando-o no pane explorador \
        ou no pane propriedadese escolhendo a opção \"Remover do Modelo\" no \
        menu que aparece com um clique direito no rato.
critics.CrInvalidPseudoStateTrigger-head = Remova Disparador da Transição de \
        Junta de saída
critics.CrInvalidSynch-desc = Este estado de sincronia tem transições \
        inválidas. Normalmente todas as transições de entrada para um estado\
        de sincronia vêm da mesma região e todas as transições de saída para \
        um estado de sincronia vão para a mesma região. Além disso, os \
        contentores dos estados de fonte e destino de transição têm de ser \
        regiões concorrentes.\n\nÉ necessário definir transições válidas para \
        completar a especificação comportamental do seu desenho.\n\nPara \
        corrigir isto, remova transições clicando na transição no diagrama e \
        carregando em \"Ctrl-Delete\". Também pode mudar os estados de fonte e \
        destino das transições.
critics.CrInvalidSynch-head = Mude as Transições de Estados de Sincronia
critics.CrJoinIncomingTransition-desc = O alvo de <ocl>self</ocl> é um \
        Pseudo-estado de Junta mas a sua fonte não é um Estado. Um segmento de \
        junta deve sempre originar de um estado \n\nÉ necessário definir \
        transições válidas para completar a especificação comportamental do \
        seu desenho.\n\nPara corrigir isto, remova esta transição clicando \
        clicando nela no diagrama e carregando em \"Ctrl-Delete\". Também pode \
        mudar os estados de fonte e destino das transições.
critics.CrJoinIncomingTransition-head = Fonte inválida para transição
critics.CrLinkWithoutStimulus-desc = Em diagramas de sequência, um objecto de \
        emissão envia estímulos no objecto receptor sobre uma ligação. A \
        ligação é só uma conexão de comunicação, pelo que é necessário um \
        estímulo.
critics.CrLinkWithoutStimulus-head = Sem Estímulos nestas Ligações
critics.CrMergeClasses-desc = Em classe em foco, <ocl>self</ocl>, só \
        participa numa associação e essa associação é uma associação 1-1 com \
        outra classe. Uma vez que instâncias destas duas classes têm de ser \
        sempre criadas e destruídas juntas, combinar estas classes numa única \
        pode simplificar o seu desenho sem perda de poder de representação. \
        Contudo, pode chegar à conclusão de que a classe combinada é demasiado \
        grande e complexa, pelo que nesse caso ter as classes separadas é \
        geralmente melhor. Organizar classes de modo a gerir a complexidade do \
        desenho é sempre importante, especialmente quando esse desenho já de \
        si é complexo. \n\nPara resolver isto, clique no botão \"Próximo>\", \
        ou adicione manualmente os atributos e operações da classe em foco à \
        outra classe, e por fim remova a classe focada do projecto.
critics.CrMergeClasses-head = Considere Combinar Classes (<ocl>self</ocl>)
critics.CrMissingAttrName-desc = Cada atributo tem de ter um nome.\n\n\
        Nomemclatura clara e não ambígua é um elemento chave da geração de \
        código e torna o desenho muito mais compreensível e fácil de manter.\
        Para resolver isto, use o botão \"Próximo>\", ou seleccione \
        manualmente o atributo e use o separador Propriedades para lhe dar um \
        nome.
critics.CrMissingAttrName-head = Escolha um nome
critics.CrMissingClassName-desc = Cada classe e interface num pacote tem de \
        ter um nome.\n\nNomemclatura clara e não ambígua é um elemento chave \
        da geração de código e torna o desenho muito mais compreensível e \
        fácil de manter. Para resolver isto, use o botão \"Próximo>\", ou \
        seleccione manualmente a classe e use o separador Propriedades para \
        lhe dar um nome.
critics.CrMissingClassName-head = Escolha um nome
critics.CrMissingOperName-desc = Cada operação tem de ter um nome. \n\n\
        Nomemclatura clara e não ambígua é um elemento chave da geração de \
        código e torna o desenho muito mais compreensível e fácil de manter.\n\
        \n Para resolver isto, use o botão \"Próximo>\", ou seleccione \
        manualmente a operação e use o separador Propriedades para lhe dar um \
        nome.
critics.CrMissingOperName-head = Escolha um nome
critics.CrMissingStateName-desc = Cada estado numa máquina de estados deve ter \
        um nome.\n\nNomemclatura clara e não ambígua é um elemento chave da \
        geração de código e torna o desenho muito mais compreensível e fácil \
        de manter.\n\nPara resolver isto, use o botão \"Próximo>\", ou \
        seleccione manualmente o estado e use o separador Propriedades para \
        lhe dar um nome, ou ainda seleccione o estado e escreva o nome.
critics.CrMissingStateName-head = Escolha um nome
critics.CrMultiComposite-desc = Uma instância não pode pertencer por \
        composição a mais de que uma instância composta. Tem de mudar a \
        multiplicidade na ponta de composição da associação para 0..1 ou 1..1 \
        para que o seu modelo faça sentido.\r\n\r\nLembre-se de que a \
        composição é mais forte de que a agregação. O problema pode ser \
        comparado por analogia a um modelo em que um dedo pode fazer parte \
        integrada de mais que uma mão em simultâneo.\r\n\r\nTrata-se da \
        segunda regra de bem-formação de uma ponta de associação em UML 1.4.
critics.CrMultiComposite-head = Ponta de Associação Composta com \
        Multiplicidade > 1
critics.CrMultipleAgg-desc = Só um único fim de uma Associação binária pode \
        ser agregado ou composto.\n\nA agregação e a composição são usadas \
        para indicar relação de parte-todo, e por definição, a ponta \"parte\" \
        não pode ser agregada.\n\nPara resolver isto, seleccione \"Próximo>\" \
        para usar o assistente, ou seleccione manualmente a Associação e \
        defina alguns dos seus papeis de agregação para Nenhum.
critics.CrMultipleAgg-head = Duas Pontas de Agregação (Papeis) numa Associação \
        Binária.
critics.CrMultipleDeepHistoryStates-desc = Existem mútiplos estados de \
        história profunda ambíguos nesta máquina ou estado composto. \
        Normalmente cada máquina de estados ou estado composto só tem um único \
        estado de história profunda.\n\nÉ necessário definir estados de \
        história não ambíguos de forma a completar a parte de especificação \
        comportamental do seu desenho.\n\nPara corrigir isto, seleccione um \
        dos estados de história profunda e apague-o, carregando em \
        \"Ctrl-Delete\".
critics.CrMultipleDeepHistoryStates-head = Remova Estados de História Profunda \
        a mais
critics.CrMultipleInheritance-desc = <ocl>self</ocl> tem múltiplas classes \
        base, mas o Java não suporta herança múltipla. Para tal, terá de usar \
        interfaces.\n\nEsta mudança é obrigatória antes que possa gerar código \
        Java.\n\nPara resolver isto, use o botão \"Próximo>\", ou manualmente: \
        (1) remova uma das classes base e depois (2) opcionalmente defina uma \
        interface com as mesmas declarações de métodos e (3) adicione-a como \
        uma interface de <ocl>self</ocl>, e (4) mova os corpos dos métodos \
        da classe de base antiga para <ocl>self</ocl>.
critics.CrMultipleInheritance-head = Mude Herança Múltipla para Interfaces
critics.CrMultipleInitialStates-desc = Existem múltiplos estados iniciais \
        ambíguos nesta máquina de estados ou estado composto. Normalmente cada \
        máquina de estados ou estado composto só tem um estado inicial.\n\nÉ \
        necessário definir estados não ambíguos de forma a completar a \
        parte de especificação comportamental do seu desenho.\n\nPara resolver \
        isto, carregue no botão \"Próximo>\", or seleccione manualmente um dos \
        estados iniciais a mais e remova-o.
critics.CrMultipleInitialStates-head = Remova Estados Iniciais a mais
critics.CrMultipleRealization-desc = <ocl>self</ocl> implementa múltiplas \
        interfaces. Embora isto seja válido em UML este código não irá \
        compilar em Java. Substitua as múltiplas realizações com \
        generalizações se quiser criar código compilável e livre de erros.
critics.CrMultipleRealization-head = Mude Realização Múltipla em \
        <ocl>self</ocl> para Generalizações
critics.CrMultipleShallowHistoryStates-desc = Existem mútiplos estados de \
        história superficial ambíguos nesta máquina ou estado composto. \
        Normalmente cada máquina de estados ou estado composto só tem um único \
        estado de história superficial.\n\nÉ necessário definir estados de \
        história não ambíguos de forma a completar a parte de especificação \
        comportamental do seu desenho.\n\nPara corrigir isto, seleccione um \
        dos estados de história superficial e apague-o, carregando em \
        \"Ctrl-Delete\".
critics.CrMultipleShallowHistoryStates-head = Remova Estados de História \
        Superficial a mais
critics.CrNWayAgg-desc = Associações ternárias (ou mais) não podem ter pontas \
        de associação (papeis) agregadas.\n\nA agregação e composição são \
        usadas para indicar relação de parte-todo, e por definição só se \
        aplicam a associações binárias entre artefactos.\n\nPara resolver isto \
        , seleccione manualmente a associação e defina a agregação de cada uma \
        das suas pontas (papeis) para Nenhum.
critics.CrNWayAgg-head = Ponta de Agregação (Papel) em Associação Ternária (ou \
        mais).
critics.CrNameConflict-desc = Nomes de elementos contidos num nome de espaços \
        (por exemplo, pacotes) têm de ser únicos. O elemento <ocl>self</ocl> \
        viola esta condição. Esta condição não se aplica para nomes de \
        Associações ou Generalizações.
critics.CrNameConflict-head = Conflito de Nomes Causado por <ocl>self</ocl>
critics.CrNameConflictAC-desc = Nomes de papeis de associação de classe \
        associativa não podem entrar em conflito com nomes de funcionalidades \
        estruturais (por exemplo, variáveis de instância) da classe.
critics.CrNameConflictAC-head = Nome de Papel entra em Conflito com Membro
critics.CrNameConfusion-desc = Os nomes devem ser claramente distintos uns dos \
        outros. Estes dois nomes são tão parecidos um com o outro, que \
        pessoas que lêem o código podem ficar confusas.\n\nNomemclatura clara \
        e não ambígua é o elemento chave da geração de código e torna o \
        desenho muito mais compreensível e fácil de manter. \n\nPara resolver \
        isto, use o botão \"Próximo>\", ou seleccione manualmente os elementos \
        e use o separador das Propriedades para mudar-lhes o nome. Evite nomes \
        que difiram de outros nomes apenas na capitalização dos caracteres, ou \
        underscore, or por apenas um caracter.
critics.CrNameConfusion-head = Reveja o Nome para Evitar Confusão
critics.CrNavFromInterface-desc = Associações que envolvam uma interface não \
        podem ser navegaveis na direcção da interface. Isto acontece pelo \
        facto de que as interfaces só podem conter declarações de operações e \
        não podem ter apontadores para outros objectos.\n\nEsta parte do \
        desenho deve ser mudada antes de ser usada para gerar código. Código \
        gerado sem resolver este problema não vai de encontro ao desenho \
        pretendido.\n\nPara resolver isto, seleccione a associação e use o \
        separador \"Propriedades\" para seleccionar por sua vez cada ponta de \
        de associação que NÃO está ligada à interface. Desmarque \"Navegável\" \
        para cada uma dessas pontas.\n\nA associação deve então ficar com a \
        aparência de uma seta apontada para a interface.\n\nNOTA. O ArgoUML \
        não deve permitir a criação de associações que são navegáveis a partir \
        de interfaces.\n\nAVISO. A versão corrente do ArgoUML tem um defeito \
        conhecido onde cria uma associação entre uma classe e interface que é \
        navegável nas duas direcções, ou somente da interface para a classe. \
        Se esta a critica for disparada, a correcção passa por remover a \
        navegação da ponta da associação do lado daclasse, e se necessário, \
        adicionar navegação na ponta do lado da interface.
critics.CrNavFromInterface-head = Remova a Navegação de Interface via a \
        Associação <ocl>self</ocl>
critics.CrNoAssociations-desc = Ainda não especificou nenhuma associação para \
        <ocl>self</ocl>.Normalmente as clases, actores e casos de utilização \
        estão associados com outros.\n\nDefinir as associações entre objectos \
        é uma parte importante do seu desenho.\n\nPara resolver isto, carregue \
        no botão \"Próximo>\", ou adicione associações manualmente clicando na \
        ferramenta de associação na barra de ferramentas e arrastando de \
        <ocl>self</ocl> para outro nó.
critics.CrNoAssociations-head = Adicione Associações a <ocl>self</ocl>
critics.CrNoGuard-desc = A Transposição em foco é incompleta porque não tem \
        condição de guarda. Condições de guarda têm de ser verdadeiras para a \
        transição ocorrer. \n\nEste problema tem de ser resolvido de modo a \
        completar a máquina de estados.\n\nPara resolver isto, seleccione a \
        Transição e use o separador \"Propriedades\", ou seleccione a \
        Transição e escreva algum texto na forma:\n[CONDIÇÃO-DE-GUARDA]\nOnde \
        CONDIÇÃO-DE-GUARDA é uma expressão booleana.
critics.CrNoGuard-head = Adicione Condição de Guarda à Transição
critics.CrNoIncomingTransitions-desc = O estado <ocl>self</ocl> não tem \
        transições de entrada. Normalmente, os estados têm transições de \
        entrada e saída.\n\nÉ necessário definir transições de estado \
        completas de forma a completar a parte de especificação comportamental \
        do seu desenho. Sem transições de entrada, este estado não é alcançável\
        .\n\nPara resolver isto, carregue no botão \"Próximo>\", ou adicione \
        transições manualmente clicando na ferramente de transição na barra de \
        ferramentas e arrastando de outro estado para <ocl>self</ocl>.
critics.CrNoIncomingTransitions-head = Adicione Transições de Entrada a \
        <ocl>self</ocl>
critics.CrNoInitialState-desc = Não existe nenhum estado inicial nesta máquina \
        de estados ou estado composto. Normalmente cada máquina de estados ou \
        estao composto tem um estado inicial.\n\nÉ necessário definir estados \
        não ambíguos de forma a completar a parte da especificação \
        comportamental do seu desenho.\n\nPara resolver isto, carregue no \
        botão \"Próximo>\", ou seleccione manualmente estado inicial da barra \
        de ferramentas e coloque-a no diagrama.
critics.CrNoInitialState-head = Coloque um Estado Inicial
critics.CrNoInstanceVariables-desc = Ainda não especificou variáveis de \
        instância para <ocl>self</ocl>. Normalmente as classes têm variáveis \
        de instância que armazenam a informação do estado de cada instância. \
        Classes que só tenham atributos e métodos estáticos devem ser \
        estereótipadas com <<utility>>.\n\nÉ necessário definir variáveis de \
        instância de modo a completar a parte de representação de informação \
        do seu desenho.\n\nPara resolver isto, carregue no botão \"Próximo>\", \
        ou adicione variáveis de instância com um duplo clique em \
        <ocl>self</ocl> no pane de navegação e usando o menu \"Criar\" para \
        fazer um novo atributo.
critics.CrNoInstanceVariables-head = Adicione Variáveis de Instância a \
        <ocl>self</ocl>
critics.CrNoOperations-desc = Ainda não especificou operações para \
        <ocl>self</ocl>. Normalmente as classes têm operações que definem o \
        seu comportamento.\n\nÉ necessário definir operações de modo a \
        completar a parte de especificação comportamental do seu desenho.\n\n\
        Para resolver isto, carregue no botão \"Próximo>\", ou adicione \
        operações manualmente clicando em <ocl>self</ocl> no pane de navegação \
        e usando o menu \"Criar\" para fazer uma nova operação.
critics.CrNoOperations-head = Adicione Operações a <ocl>self</ocl>
critics.CrNoOutgoingTransitions-desc = O estado <ocl>self</ocl> não tem \
        transições de saída. Normalmente, os estados têm transições de \
        entrada e saída.\n\nÉ necessário definir transições de estado \
        completas de forma a completar a parte de especificação comportamental \
        do seu desenho. Sem transições de saída, este estado é um estado \
        \"morto\", pois não tem saída.\n\nPara resolver isto, carregue no \
        botão \"Próximo>\", ou adicione transições manualmente clicando na \
        ferramenta de transição na barra de ferramentas e arrastando de \
        <ocl>self</ocl> para outro estado.
critics.CrNoOutgoingTransitions-head = Adicione Transições de Saída de \
        <ocl>self</ocl>
critics.CrNoTransitions-desc = O estado <ocl>self</ocl> não tem \
        transições de entrada nem de saída. Normalmente, os estados têm \
        transições de entrada e saída.\n\nÉ necessário definir transições de \
        estado completas de forma a completar a parte de especificação \
        comportamental do seu desenho. \n\nPara resolver isto, carregue no \
        botão \"Próximo>\", ou adicione transições manualmente clicando na \
        ferramenta de transição na barra de ferramentas e arrastando de \
        <ocl>self</ocl> para outro estado ou de outro estado para \
        <ocl>self</ocl>.
critics.CrNoTransitions-head = Adicione Transições a <ocl>self</ocl>
critics.CrNoTriggerOrGuard-desc = A Transição em foco está incompleta porque \
        não tem nenhum disparador ou condição de guarda. Os Disparadores são \
        eventos que causam que uma transição se dê. Condições de guarda têm de \
        ser verdadeiras para que a transição se dê. Se só a condição de guarda \
        é usada, então a transição sucede quando a condição fica verdadeira. \
        \n\nEste problema tem de ser resolvido para completar a máquina de \
        estados.\n\nPara resolver isto, seleccione a Transição e use o \
        separador \"Propriedades\", ou seleccione a Transição e escreva algum \
        texto na seguinte forma:\nDISPARADOR [CONDIÇÃO-DE-GUARDA] / ACÇÃO\n\
        Onde DISPARADOR é o nome de um evento, CONDIÇÃO-DE-GUARDA é uma \
        expressão booleana e ACÇÃO é uma acção para ser desempenhada quando a \
        Transição se dá. Todas estas três partes são opcionais.
critics.CrNoTriggerOrGuard-head = Adicione Disparador ou Condição de Guarda à \
        Transição
critics.CrNodeInsideElement-desc = Os Nós normalmente não se encontram dentro \
        de outros Elementos. Eles representam objectos fisicos em tempo de \
        execução com recursos, geralmente com pelo menos uma memória mas \
        também muitas vezes com capacidade de processamento.
critics.CrNodeInsideElement-head = Os Nós Geralmente Não Estão Contidos
critics.CrNodeInstanceInsideElement-desc = As instâncias de Nós normalmente \
        não se encontram dentro de outros Elementos. Eles representam objectos \
        fisicos em tempo de execução com recursos, geralmente com pelo menos \
        uma memória mas também muitas vezes com capacidade de processamento.
critics.CrNodeInstanceInsideElement-head = As Instâncias de Nós Geralmente Não \
        Estão Contidas
critics.CrNodesOverlap-desc = Alguns dos objectos neste diagrama sobrepõem-se, \
        obscurecendo-se uns aos outros. Podem estar a esconder informção \
        importante, tornando-se dificil de entender para os humanos. Uma \
        aparência agradável também pode tornar os seus diagramas mais \
        influentes para outros desenhadores, implementadores e tomadores de \
        decisão.\n\nConstruir um conjunto de diagramas de classes \
        compreensível é uma parte importante do seu desenho.\n\nPara resolver \
        isto, mova os nós focados no diagrama.
critics.CrNodesOverlap-head = Limpe o Diagrama <ocl>self</ocl>
critics.CrNonAggDataType-desc = Os Tipos de Dados não são classes completas e \
        não podem ser associados com classes, excepto se o Tipo de Dados faz \
        parte de uma composição (losangulo negro).\n\nUm bom desenho OO \
        depende das escolhas cuidadosas acerca de quais entidades representar \
        como objectos completos e quais representar como atributos de objectos\
        .\n\nPara resolver isto, carregue no botão \"Próximo>\", ou substitua \
        manualmente o Tipo de Dados por uma classe completa ou mude a \
        associação de agregação para ser contida por uma classe completa.
critics.CrNonAggDataType-head = Encapsule o Tipo de Dados
critics.CrObjectWithoutComponent-desc = Em Diagramas de Instalação os objectos \
        encontram-se normalmente dentro de componentes ou instâncias de \
        componentes.
critics.CrObjectWithoutComponent-head = Os Objectos Estão Normalmente Dentro \
        de Componentes
critics.CrOperNameConflict-desc = Duas operações em <ocl>self</ocl> têm \
        exactamente a mesma assinatura. As Operações têm de ter assinaturas \
        distintas. Uma assinatura é a combinação do nome de uma operação e \
        tipos de parâmetros (excluíndo parâmetros de retorno).\n\nAssinaturas \
        ambiguas reduzem a clareza e introduzem o pontencial para \
        processamento incorrecto. Além disso, não é possível gerar código para \
        as linguagens convencionais OO.\n\nPara resolver isto, seleccione uma \
        das operações em conflito nesta classe e mude o seu nome ou parâmetros.
critics.CrOperNameConflict-head = Mude Nomes de Operação ou Assinaturas em \
        <ocl>self</ocl>
critics.CrOppEndConflict-desc = Two roles of <ocl>self</ocl> have the same \
        name. Roles must have distinct names. \n\nClear and unambiguous names \
        are key to code generation and producing an understandable and \
        maintainable design.\n\nTo address this, use the \"Next>\" button, or \
        manually select the one of the conflicting roles at the far end of an \
        association from this class and change its name.
critics.CrOppEndConflict-head = Rename Association Roles
critics.CrOppEndVsAttr-desc = Two attributes may not have the same name within \
        a Classifier.\n\nThis is the second well-formedness rule on Classifier \
        in UML 1.4.
critics.CrOppEndVsAttr-head = Rename Role or Attribute
critics.CrParamTypeNotImported-desc = The type of each operation parameter \
        must be visible and imported into the class that owns the \
        operation.\n\nImporting classes is needed for code generation. Good \
        modularization of classes into packages is key to an understandable \
        design.\n\nTo address this, use the \"Next>\" button, or manually add \
        an import to the class that owns this operation.
critics.CrParamTypeNotImported-head = Import Parameter Type into Class
critics.CrReservedName-desc = \"<ocl>self</ocl>\" is a reserved word or very \
        close to one.  The names of model elements must not conflict with \
        reserved words of programming languages or UML.\n\nUsing legal names \
        is needed to generate compilable code. \n\nTo address this, use the \
        \"Next>\" button, or manually select the highlighted element and use \
        the Properties tab to give it a different name.
critics.CrReservedName-head = Change <ocl>self</ocl> to a Non-Reserved Word
critics.CrReturnWithoutCall-desc = Every return-action requires a call- or \
        send-action,\n but this Link has no corresponding call- or send-action.
critics.CrReturnWithoutCall-head = Missing Call(Send)-Action
critics.CrSeqInstanceWithoutClassifier-desc = Instances have a classifier
critics.CrSeqInstanceWithoutClassifier-head = Set Classifier
critics.CrSingletonViolatedMissingStaticAttr-desc = <ocl>self</ocl> is marked \
        with the <<singleton>>; stereotype, but it does not satisfy the \
        constraints imposed on Singletons.\nIt does not have a static \
        attribute (a class variable) to hold the instance.\n\nWhenever you \
        mark a class with a stereotype, the class should satisfy all \
        constraints of the stereotype.  This is an important part of making a \
        self-consistent and understandable design. Using the Singleton Pattern \
        can save time and memory space.\n\nIf you no longer want this class to \
        be a Singleton, remove the <<singleton>> stereotype by clicking on the \
        class and selecting the blank selection on the stereotype drop-down \
        within the properties tab.\n
critics.CrSingletonViolatedMissingStaticAttr-head = Singleton Stereotype \
        Violated, Missing Static Attribute in <ocl>self</ocl>
critics.CrSingletonViolatedOnlyPrivateConstructors-desc = <ocl>self</ocl> is \
        marked with the <<singleton>>; stereotype, but it does not satisfy the \
        constraints imposed on Singletons.\nIt must have only private \
        constructors so that new instances cannot be made by other \
        code.\nWhenever you mark a class with a stereotype, the class should \
        satisfy all constraints of the stereotype.  This is an important part \
        of making a self-consistent and understandable design. Using the \
        Singleton Pattern can save time and memory space.\n\nIf you no longer \
        want this class to be a Singleton, remove the <<singleton>> stereotype \
        by clicking on the class and selecting the blank selection on the \
        stereotype drop-down within the properties tab.\n
critics.CrSingletonViolatedOnlyPrivateConstructors-head = Singleton Stereotype \
        Violated, Has Non-Private Constructor in <ocl>self</ocl>
critics.CrStimulusWithWrongPosition-desc = In sequence-diagrams the \
        sender-side of the communication-connections of these\nstimuli are \
        connected at the beginning of an activation. To be a sender an object \
        must\nhave a focus-of-control first.
critics.CrStimulusWithWrongPosition-head = Wrong Position of These Stimuli
critics.CrSubclassReference-desc = Class <ocl>self</ocl> has a reference to \
        one of it's subclasses. Normally all subclasses should be treated \
        \"equally\" by the superclass.  This allows for addition of new \
        subclasses without modification to the superclass. \n\nDefining the \
        associations between objects is an important part of your design.  \
        Some patterns of associations are easier to maintain than others, \
        depending on the nature of future changes. \n\nTo address this, press \
        the \"Next>\" button, or remove the association manually by clicking \
        on it in the diagram and pressing Delete.
critics.CrSubclassReference-head = Remove Reference to Specific Subclass
critics.CrTooManyAssoc-desc = There are too many Associations on class \
        <ocl>self</ocl>.  Whenever one class becomes too central to the design \
        it may become a maintenance bottleneck that must be updated \
        frequently. \n\nDefining the associations between objects is an \
        important part of your design. \n\nTo address this, press the \
        \"Next>\" button, or remove associations manually by clicking on an \
        association in the navigator pane or diagram and pressing the \"Del\" \
        key.
critics.CrTooManyAssoc-head = Reduce Associations on <ocl>self</ocl>
critics.CrTooManyAttr-desc = There are too many Attributes on class \
        <ocl>self</ocl>.  Whenever one class becomes too central to the design \
        it may become a maintenance bottleneck that must be updated \
        frequently. \n\nDefining the attributes of objects is an important \
        part of your design. \n\nTo address this, press the \"Next>\" button, \
        or remove attributes manually by double-clicking on the attribute \
        compartment of the  highlighted class in the diagram and removing the \
        line of text for an attribute.
critics.CrTooManyAttr-head = Reduce Attributes on <ocl>self</ocl>
critics.CrTooManyClasses-desc = There are too many classes in <ocl>self</ocl>. \
        If one class diagram has too many classes it may become very difficult \
        for humans to understand. \n\nDefining an understandable set of class \
        diagrams is an important part of your design. \n\nTo address this, \
        press the \"Next>\" button, or remove classes manually by clicking on \
        a class in the navigator pane or diagram and pressing the \"Del\" key. \
         Or you can make a new diagram...
critics.CrTooManyClasses-head = Reduce Classes in Diagram <ocl>self</ocl>
critics.CrTooManyOper-desc = There are too many Operations on class \
        <ocl>self</ocl>.  Whenever one class becomes too central to the design \
        it may become a maintenance bottleneck that must be updated \
        frequently. \n\nDefining the operations of objects is an important \
        part of your design. \n\nTo address this, press the \"Next>\" button, \
        or remove operations manually by double-clicking on the operation \
        compartment of the  highlighted class in the diagram and removing the \
        line of text for an operation.
critics.CrTooManyOper-head = Reduce Operations on <ocl>self</ocl>
critics.CrTooManyStates-desc = There are too many States in <ocl>self</ocl>.  \
        If one state machine has too many states it may become very difficult \
        for humans to understand. \n\nDefining an understandable set of states \
        is an important part of your design. \n\nTo address this, press the \
        \"Next>\" button, or remove states manually by clicking on a states in \
        the navigator pane or diagram and pressing the \"Del\" key.  Or you \
        can nest states...
critics.CrTooManyStates-head = Reduce States in Machine <ocl>self</ocl>
critics.CrTooManyTransitions-desc = There are too many Transitions on state \
        <ocl>self</ocl>.  Whenever one state becomes too central to the \
        machine it may become a maintenance bottleneck that must be updated \
        frequently. \n\nDefining the transitions between states is an \
        important part of your design. \n\nTo address this, press the \
        \"Next>\" button, or remove transitions manually by clicking on a \
        transition in the navigator pane or diagram and pressing the \"Del\" \
        key.
critics.CrTooManyTransitions-head = Reduce Transitions on <ocl>self</ocl>
critics.CrUnconventionalAttrName-desc = Normally attributes begin with a \
        lowercase letter. The name '<ocl>self</ocl>' is unconventional because \
        it does not.\n\nFollowing good naming conventions help to improve the \
        understandability and maintainability of the design. \n\nTo address \
        this, use the \"Next>\" button, or manually select <ocl>self</ocl> and \
        use the Properties tab to give it a different name.
critics.CrUnconventionalAttrName-head = Choose a Better Attribute Name
critics.CrUnconventionalClassName-desc = Normally classes begin with a capital \
        letter. The name '<ocl>self</ocl>' is unconventional because it does \
        not begin with a capital.\n\nFollowing good naming conventions help to \
        improve the understandability and maintainability of the design. \
        \n\nTo address this, use the \"Next>\" button, or manually select \
        <ocl>self</ocl> and use the Properties tab to give it a different name.
critics.CrUnconventionalClassName-head = Capitalize Class Name <ocl>self</ocl>
critics.CrUnconventionalOperName-desc = Normally operation names begin with a \
        lowercase letter. The name '<ocl>self</ocl>' is unconventional because \
        it does not.\n\nFollowing good naming conventions help to improve the \
        understandability and maintainability of the design. \n\nTo address \
        this, use the \"Next>\" button, or manually select <ocl>self</ocl> and \
        use the Properties tab to give it a new name.
critics.CrUnconventionalOperName-head = Choose a Better Operation Name
critics.CrUnconventionalPackName-desc = Normally package names are written in \
        all lower case with periods used to indicate \"nested\" packages.  The \
        name '<ocl>self</ocl>' is unconventional because it is not all lower \
        case with periods.\n\nFollowing good naming conventions help to \
        improve the understandability and maintainability of the design. \
        \n\nTo address this, use the \"Next>\" button, or manually select \
        <ocl>self</ocl> and use the Properties tab to give it a different name.
critics.CrUnconventionalPackName-head = Revise Package Name <ocl>self</ocl>
critics.CrUnnavigableAssoc-desc = The Association <ocl>self</ocl> is not \
        navigable in any direction. All associations should be navigable at \
        least one way.\n\nSetting the navigability of associations allows your \
        code to access data by following pointers. \n\nTo address this, select \
        association \"<ocl>self</ocl>\" in the diagram or navigator panel and \
        click the properties tab.  Then use the checkboxes at the bottom of \
        the properties panel to turn on navigability.
critics.CrUnnavigableAssoc-head = Make <ocl>self</ocl> Navigable
critics.CrUselessAbstract-desc = <ocl>self</ocl> can never influence the \
        running system because it can never have any instances, and none of \
        its subclasses can have instances either. \n\nTo address this problem: \
        (1) define concrete subclasses that implement the interface of this \
        class; or (2) make <ocl>self</ocl> or one of its existing subclasses \
        concrete.
critics.CrUselessAbstract-head = Define Concrete (Sub)Class
critics.CrUselessInterface-desc = <ocl>self</ocl> can never be used because no \
        classes implement it.\n\nTo address this problem, press the \"Next>\" \
        button or manually use the toolbar \"Class\" button to define classes \
        and the \"Realizes\" button to make a relationship from the class to \
        the highlighted interface.
critics.CrUselessInterface-head = Define Class to Implement <ocl>self</ocl>
critics.CrUtilityViolated-desc = <ocl>self</ocl> is marked with the \
        <<utility>>; stereotype, but it does not satisfy the constraints \
        imposed on Utilities.\nIt does have instance attributes, variables or \
        operations.\n\nIf you no longer wants this class to be a Utility, \
        remove the <<utility>> stereotype by clicking on the class and \
        selecting the blank selection on the stereotype drop-down within the \
        properties tab.\n
critics.CrUtilityViolated-head = Utility Stereotype Violated, Instances Can Be \
        Created.
critics.CrWrongLinkEnds-desc = In deployment-diagrams objects can reside \
        either on components\n or on component-instances. So it is not \
        possible to have two objects\n connected with a Link, while one object \
        resides on an component and\n an the other object on a \
        component-instance.\n\n\n To address this remove one object of the two \
        connected objects from its location to an element that has the\n same \
        type as the location of the other object
critics.CrWrongLinkEnds-head = LinkEnds Don't Have The Same Locations
critics.CrZeroLengthEdge-desc = This edge is too small to see easily. This may \
        hide important information and make it difficult for humans to \
        understand. A neat appearance may also make your diagrams more \
        influential on other designers, implementers, and decision \
        makers.\n\nConstructing an understandable set of diagrams is an \
        important part of your design. \n\nTo address this, move one or more \
        nodes so that the highlighted edges will be longer, or click in the \
        center of the edge and drag to make a new vertex.
critics.CrZeroLengthEdge-head = Make Edge More Visible
